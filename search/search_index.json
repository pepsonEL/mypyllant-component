{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Home Assistant component that interfaces with the myVAILLANT API (and branded versions of it, such as the MiGo Link app from Saunier Duval &amp; Bulex). Uses the myPyllant library.</p>"},{"location":"#installation","title":"Installation","text":"<p>Note</p> <ol> <li>The developers are not affiliated with Vaillant, we take no responsibility for anything that happens to your devices because of this library</li> <li>This integration is not compatible with systems that use sensoAPP and multiMATIC</li> </ol>"},{"location":"#hacs","title":"HACS","text":"<ol> <li>Install HACS</li> <li>Search for the myVAILLANT integration in HACS and install it</li> <li>Restart Home Assistant</li> <li>Add myVaillant integration</li> <li>Sign in with the email &amp; password you used in the myVAILLANT app (or MiGo app for Saunier Duval)</li> </ol>"},{"location":"#manual","title":"Manual","text":"<ol> <li>Download the latest release</li> <li>Extract the <code>custom_components</code> folder to your Home Assistant's config folder, the resulting folder structure should    be <code>config/custom_components/mypyllant</code></li> <li>Restart Home Assistant</li> <li>Add myVaillant integration, or go to    Settings &gt; Integrations and add myVAILLANT</li> <li>Sign in with the email &amp; password you used in the myVAILLANT app (or MiGo app for Saunier Duval)</li> </ol>"},{"location":"#tested-setups","title":"Tested Setups","text":"<ul> <li>Vaillant aroTHERM plus heatpump + sensoCOMFORT VRC 720 + sensoNET VR 921</li> <li>Vaillant ECOTEC PLUS boiler + VR940F + sensoCOMFORT</li> <li>Vaillant ECOTEC PLUS boiler + VRT380f + sensoNET</li> <li>Vaillant ECOTEC PLUS VCW20/1 boiler + sensoCOMFORT VRC 720 + sensoNET VR 921</li> <li>Vaillant ECOTEC PLUS 296/5-5 (R6) + sensoCOMFORT VRC 720/2 + VR 70 (2 circuits) + sensoNET VR 921</li> <li>Saunier Duval DUOMAX F30 90 + MISET Radio + MiLink V3</li> <li>Bulex Thema Condens F30/35 + Red 5 + MiPro Sense + MiLink v3</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Supports climate &amp; hot water controls, as well as sensor information</li> <li>Control operating modes, target temperature, and presets such as holiday more or quick veto</li> <li>Set the schedule for climate zones, water heaters, and circulation pumps   with a custom service</li> <li>Track sensor information of devices, such as temperature, humidity, operating mode, energy usage, or energy efficiency</li> <li>See diagnostic information, such as the current heating curve, flow temperature, firmware versions, or water pressure</li> <li>Custom services to set holiday mode or quick veto temperature overrides, and their duration</li> </ul>"},{"location":"#options","title":"Options","text":""},{"location":"#seconds-between-scans","title":"Seconds between scans","text":"<p>Wait interval between updating (most) sensors. The energy data and efficiency sensors have a fixed hourly interval.</p>"},{"location":"#delay-before-refreshing-data-after-updates","title":"Delay before refreshing data after updates","text":"<p>How long to wait between making a request (i.e. setting target temperature) and refreshing data. The Vaillant takes some time to return the updated values.</p>"},{"location":"#default-duration-in-hours-for-quick-veto","title":"Default duration in hours for quick veto","text":"<p>When setting the temperature with the climate controls, the integration uses the \"quick veto\" feature of the myVAILLANT app.</p> <p>With this option you can set for how long the temperature should stay set, before returning to the default value.</p>"},{"location":"#default-duration-in-days-for-away-mode","title":"Default duration in days for away mode","text":"<p>When the away mode preset is activated, this duration is used to for the end date (default is 365 days).</p>"},{"location":"#temperature-controls-overwrite-time-program-instead-of-setting-quick-veto","title":"Temperature controls overwrite time program instead of setting quick veto","text":"<p>When raising or lowering the desired temperature in the myVAILLANT app, it sets a quick veto mode for a limited time with that new temperature, if the zone is in time controlled mode. If you want to permanently change the desired temperature, you need to update the time schedule.</p> <p>By default, this integration has the same behavior. But when enabling this option, the Home Assistant climate controls instead overwrite the temperatures set in the time schedule with the new value (unless quick veto is already active).</p>"},{"location":"#country","title":"Country","text":"<p>The country you registered your myVAILLANT account in. The list of options is limited to known supported countries.</p>"},{"location":"#brand","title":"Brand","text":"<p>Brand of your HVAC equipment and app, pick Saunier Duval if you use the MiGo Link app.</p>"},{"location":"#supported-brands-countries","title":"Supported Brands &amp; Countries","text":"<p>Missing a Country?</p> <p>If a country is missing, please open an issue or contribute a new country to the myPyllant library.</p> <ul> <li>Vaillant<ul> <li>Albania</li> <li>Austria</li> <li>Belgium</li> <li>Bulgaria</li> <li>Croatia</li> <li>Czechia</li> <li>Denmark</li> <li>Estonia</li> <li>Finland</li> <li>France</li> <li>Georgia</li> <li>Germany</li> <li>Greece</li> <li>Hungary</li> <li>Italy</li> <li>Latvia</li> <li>Lithuania</li> <li>Luxembourg</li> <li>Netherlands</li> <li>Norway</li> <li>Poland</li> <li>Portugal</li> <li>Romania</li> <li>Serbia</li> <li>Slovakia</li> <li>Slovenia</li> <li>Spain</li> <li>Sweden</li> <li>Switzerland</li> <li>Ukraine</li> <li>United Kingdom</li> <li>Uzbekistan</li> </ul> </li> <li>Saunier Duval<ul> <li>Austria</li> <li>Czechia</li> <li>Finland</li> <li>France</li> <li>Greece</li> <li>Hungary</li> <li>Italy</li> <li>Lithuania</li> <li>Poland</li> <li>Portugal</li> <li>Romania</li> <li>Slovakia</li> <li>Spain</li> </ul> </li> <li>Bulex<ul> <li>Does not support country selection, just leave the option empty</li> </ul> </li> </ul>"},{"location":"#known-issues","title":"Known Issues","text":""},{"location":"#lack-of-test-data-for-different-systems","title":"Lack of Test Data for Different Systems","text":"<p>Your HVAC system might differ from the ones in Tested Setups above. If you don't see any entities, or get an error during setup, please check Debugging and create an issue. With debugging enabled, there's a chance to find the culprit in the data returned by the myVAILLANT API and fix it.</p>"},{"location":"1-automations/","title":"Automations &amp; Cards","text":""},{"location":"1-automations/#legionella-protection1","title":"Legionella Protection<sup>1</sup>","text":"<p>With the Home Assistant component, more flexible legionella protection is possible. You can tweak the time condition or the target temperature(s).</p> <pre><code>alias: Legionella Protection\ndescription: \"\"\ntrigger:\n  - platform: time\n    at: \"10:00:00\"\ncondition:\n  - condition: time\n    weekday:\n      - sun  # (1)\naction:\n  - service: water_heater.set_temperature\n    data:\n      temperature: 75 # (2)\n    target:\n      entity_id: water_heater.domestic_hot_water_0\n  - delay:\n      hours: 8 # (3)\n      minutes: 0\n      seconds: 0\n      milliseconds: 0\n  - service: water_heater.set_temperature\n    data:\n      temperature: 50 # (4)\n    target:\n      entity_id: water_heater.domestic_hot_water_0\nmode: single\n</code></pre> <ol> <li>You can customize the frequency and weekday here,    see Time condition documentation</li> <li>Here you can set the target temperature for legionella protection</li> <li>This is the duration. Make sure it covers the time period where your water heater is turned on</li> <li>This should be your regular water temperature</li> </ol>"},{"location":"1-automations/#turning-off-water-heater-with-climate-away-mode","title":"Turning off Water Heater with Climate Away Mode","text":"<p>With these two automations, your water heater turns on and off with the away mode of your climate entity.</p> <pre><code>alias: Water heater off during Zone 1 away mode\ndescription: \"\"\ntrigger:\n  - platform: state\n    entity_id:\n      - climate.home_zone_1_circuit_0_climate # (1)\n    attribute: preset_mode\n    to: away\ncondition: [ ]\naction:\n  - service: water_heater.set_operation_mode\n    target:\n      entity_id:\n        - water_heater.home_domestic_hot_water_0 # (2)\n    data:\n      operation_mode: 'OFF'\nmode: single\n</code></pre> <ol> <li>Pick your climate entity</li> <li>Pick your water heater entity</li> </ol> <pre><code>alias: myVAILLANT DHW on after ending away mode\ndescription: \"\"\ntrigger:\n  - platform: state\n    entity_id:\n      - climate.home_zone_1_circuit_0_climate # (1)\n    attribute: preset_mode\n    from: away\ncondition: [ ]\naction:\n  - service: water_heater.set_operation_mode\n    target:\n      entity_id:\n        - water_heater.home_domestic_hot_water_0 # (2)\n    data:\n      operation_mode: TIME_CONTROLLED\nmode: single\n</code></pre> <ol> <li>Pick your climate entity</li> <li>Pick your water heater entity</li> </ol>"},{"location":"1-automations/#control-heating-schedule-based-on-solar-power","title":"Control Heating Schedule based on Solar Power","text":"<p>This automation delays heating until after sunrise on sunny days, to make the most of solar power. You could also use your water heater schedule, to boost tank temperature at the end of the day when solar power is still available.</p> <pre><code>alias: myVAILLANT Delay Heating on Sunny Days\ndescription: \"\"\ntrigger:\n  - platform: calendar\n    event: start\n    offset: \"0:30:0\"\n    entity_id: calendar.home_zone_1_circuit_0_heating_schedule # (1)\ncondition:\n  - condition: numeric_state\n    entity_id: sensor.openweathermap_forecast_cloud_coverage # (2)\n    below: 50\n  - condition: sun\n    before: sunrise\naction:\n  - service: mypyllant.set_holiday\n    target:\n      entity_id: climate.home_zone_1_circuit_0_climate # (3)\n    data:\n      end: \"{{ (as_timestamp(states.sensor.sun_next_rising.state) + 1.5 * 3600) | timestamp_local }}\" # (4)\nmode: single\n</code></pre> <ol> <li>Pick your calendar entity. The offset makes sure that a little bit of heating still happens at the scheduled start</li> <li>Uses OpenWeatherMap to determine forecasted cloud coverage, only triggers if cloud coverage is below 50%</li> <li>Pick your climate entity</li> <li>Delays heating until 1,5h after sunrise</li> </ol>"},{"location":"1-automations/#climate-control-cards-with-away-mode-datepickers","title":"Climate Control Cards with Away Mode Datepickers","text":"<p>This is a sample card configuration with climate &amp; water heater controls, as well as a conditional switch for away mode that shows date pickers when away mode is enabled. You probably need to replace <code>home</code> and <code>zone_1</code> with your entity names.</p> <p></p> <p>You need the Mushroom Cards addon.</p> <pre><code>type: vertical-stack\ncards:\n  - type: custom:mushroom-chips-card\n    chips:\n      - type: entity\n        entity: binary_sensor.home_online_status\n      - type: entity\n        entity: sensor.home_zone_1_circuit_0_heating_state\n        icon: mdi:air-purifier\n      - type: entity\n        entity: sensor.home_zone_1_circuit_0_current_temperature\n      - type: entity\n        entity: sensor.home_system_water_pressure\n  - type: custom:mushroom-climate-card\n    entity: climate.home_zone_1_circuit_0_climate\n    fill_container: false\n    hvac_modes:\n      - auto\n      - heat_cool\n      - 'off'\n    show_temperature_control: false\n    collapsible_controls: false\n    icon: mdi:heat-pump\n    tap_action:\n      action: more-info\n    secondary_info: state\n  - type: custom:mushroom-entity-card\n    entity: switch.home_holiday_duration_remaining\n    tap_action:\n      action: toggle\n    fill_container: false\n    layout: horizontal\n  - type: conditional\n    conditions:\n      - condition: state\n        entity: switch.home_holiday_duration_remaining\n        state: 'on'\n    card:\n      type: entities\n      entities:\n        - entity: datetime.home_away_mode_start_date\n        - entity: datetime.home_away_mode_end_date\n  - type: horizontal-stack\n    cards:\n      - type: custom:mushroom-entity-card\n        entity: water_heater.home_domestic_hot_water_0\n        name: Hot Water\n        icon: mdi:thermometer-water\n      - type: custom:mushroom-entity-card\n        entity: switch.home_domestic_hot_water_0_boost\n        name: Hot Water Boost\n        icon: mdi:thermometer-chevron-up\n        tap_action:\n          action: toggle\n</code></pre>"},{"location":"1-automations/#customizing-schedules-in-the-calendar","title":"Customizing Schedules in the Calendar","text":"<p>Time programs can be updated from the Home Assistant calendar. You can:</p> <ul> <li>Create new time slots (make sure to select weekly repetition, and set a target temperature as the event summary)</li> <li>Update existing time slots by changing start time, end time, weekdays, or the target temperature in the event summary</li> <li>Delete time slots on a specific weekday</li> </ul> <ol> <li> <p>Contributed by CommanderROR in the Home Assistant Community \u21a9</p> </li> </ol>"},{"location":"2-entities/","title":"Entities","text":"<p>You can expect these entities, although names will vary based on your home name (here \"Home\"), installed devices (in this example \"aroTHERM plus\" and \"hydraulic station\"), or the naming of your heating zones (in this case \"Zone 1\"):</p> Entity Unit Class Sample Home Outdoor Temperature \u00b0C temperature 11.2 Home System Water Pressure bar pressure 1.4 Home Firmware Version 0357.40.32 Home Zone 1 (Circuit 0) Desired Temperature \u00b0C temperature 22.0 Home Zone 1 (Circuit 0) Current Temperature \u00b0C temperature 22.4 Home Zone 1 (Circuit 0) Humidity % humidity 46.0 Home Zone 1 (Circuit 0) Heating Operating Mode Time Controlled Home Zone 1 (Circuit 0) Heating State Idle Home Zone 1 (Circuit 0) Current Special Function None Home Circuit 0 State STANDBY Home Circuit 0 Current Flow Temperature \u00b0C temperature 26.0 Home Circuit 0 Heating Curve 1.19 Home Domestic Hot Water 0 Tank Temperature \u00b0C temperature 49.0 Home Domestic Hot Water 0 Setpoint \u00b0C temperature 52.0 Home Domestic Hot Water 0 Operation Mode Time Controlled Home Domestic Hot Water 0 Current Special Function Regular Home Heating Energy Efficiency 3.6 Home Device 0 aroTHERM plus Heating Energy Efficiency 3.6 Home Device 0 aroTHERM plus Consumed Electrical Energy Domestic Hot Water Wh energy 3000.0 Home Device 0 aroTHERM plus Consumed Electrical Energy Heating Wh energy 14000.0 Home Device 0 aroTHERM plus Earned Environment Energy Domestic Hot Water Wh energy 8000.0 Home Device 0 aroTHERM plus Earned Environment Energy Heating Wh energy 36000.0 Home Device 0 aroTHERM plus Heat Generated Heating Wh energy 50000.0 Home Device 0 aroTHERM plus Heat Generated Domestic Hot Water Wh energy 11000.0 Home Device 1 Hydraulic Station Heating Energy Efficiency unknown Home Device 1 Hydraulic Station Consumed Electrical Energy Domestic Hot Water Wh energy 0.0 Home Device 1 Hydraulic Station Consumed Electrical Energy Heating Wh energy 0.0 Home Zone 1 (Circuit 0) Climate auto Home Away Mode Start Date unknown Home Away Mode End Date unknown Home Trouble Codes problem off Home Online Status connectivity on Home Firmware Update Required update off Home Firmware Update Enabled on Home Circuit 0 Cooling Allowed off Home Holiday Duration Remaining d 0 Home Domestic Hot Water 0 Time Controlled Home Away Mode off Home Domestic Hot Water 0 Boost off"},{"location":"2-entities/#extra-state-attributes","title":"Extra State Attributes","text":"<p>Some entities come with extra state attributes for debugging and advanced usage. Your attributes may be different, depending on your devices.</p>"},{"location":"2-entities/#home-sensor","title":"Home Sensor","text":"<pre><code>continuous_heating_start_setpoint: -26\nalternative_point: -21\nheating_circuit_bivalence_point: 0\ndhw_bivalence_point: -7\nautomatic_cooling_on_off: false\nadaptive_heating_curve: true\ndhw_maximum_loading_time: 60\ndhw_hysteresis: 3\ndhw_flow_setpoint_offset: 25\ncontinuous_heating_room_setpoint: 20\nhybrid_control_strategy: BIVALENCE_POINT\nmax_flow_setpoint_hp_error: 25\ndhw_maximum_temperature: 80\nmaximum_preheating_time: 0\nparalell_tank_loading_allowed: false\noutdoor_temperature: 8.019531\nsystem_water_pressure: 1.6\noutdoor_temperature_average24h: 9.707031\ncontroller_type: VRC720\nsystem_scheme: 8\nbackup_heater_type: CONDENSING\nbackup_heater_allowed_for: DHW_AND_HEATING\nmodule_configuration_v_r71: 3\nenergy_provide_power_cut_behavior: DISABLE_HEATPUMP_AND_BACKUP_HEATER\n</code></pre>"},{"location":"2-entities/#control-error-binary-sensor","title":"Control Error Binary Sensor","text":"<pre><code>diagnostic_trouble_codes: \n- serial_number: \n  article_number: '0020260962'\n  codes: []\n- serial_number: \n  article_number: '0010021118'\n  codes: []\n- serial_number: \n  article_number: '0010023609'\n  codes: []\n- serial_number: \n  article_number: '0020260914'\n  codes: []\n</code></pre>"},{"location":"2-entities/#climate-entity","title":"Climate Entity","text":"<pre><code>hvac_modes: off, heat_cool, auto\nmin_temp: 7\nmax_temp: 35\npreset_modes: boost, none, away, sleep\ncurrent_temperature: 21.5\ntemperature: 0\ncurrent_humidity: 53\npreset_mode: none\ntime_program_heating: \n  extra_fields: {}\n  monday:\n    - extra_fields: {}\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  tuesday:\n    - extra_fields: {}\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  wednesday:\n    - extra_fields: {}\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  thursday:\n    - extra_fields: {}\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  friday:\n    - extra_fields: {}\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  saturday:\n    - extra_fields: {}\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  sunday:\n    - extra_fields: {}\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  meta_info:\n    min_slots_per_day: 0\n    max_slots_per_day: 12\n    setpoint_required_per_slot: true\n\nquick_veto_start_date_time: null\nquick_veto_end_date_time: null\n</code></pre>"},{"location":"2-entities/#circuit-state-sensor","title":"Circuit State Sensor","text":"<pre><code>room_temperature_control_mode: THERMOSTAT_FUNCTION\ncooling_flow_temperature_minimum_setpoint: 20\nheating_circuit_type: DIRECT_HEATING_CIRCUIT\nheating_circuit_flow_setpoint: 0\nheating_circuit_flow_setpoint_excess_offset: 0\nheat_demand_limited_by_outside_temperature: 19\n</code></pre>"},{"location":"2-entities/#domestic-hot-water-entity","title":"Domestic Hot Water Entity","text":"<pre><code>min_temp: 35\nmax_temp: 70\noperation_list: Manual, Time Controlled, Off, Cylinder Boost\ncurrent_temperature: 44\ntemperature: 50\ntarget_temp_high: null\ntarget_temp_low: null\noperation_mode: Time Controlled\ntime_program_dhw: \n  extra_fields: {}\n  monday:\n    - extra_fields: {}\n      start_time: 330\n      end_time: 1260\n  tuesday:\n    - extra_fields: {}\n      start_time: 330\n      end_time: 1260\n  wednesday:\n    - extra_fields: {}\n      start_time: 330\n      end_time: 1260\n  thursday:\n    - extra_fields: {}\n      start_time: 330\n      end_time: 1260\n  friday:\n    - extra_fields: {}\n      start_time: 330\n      end_time: 1260\n  saturday:\n    - extra_fields: {}\n      start_time: 450\n      end_time: 1260\n  sunday:\n    - extra_fields: {}\n      start_time: 450\n      end_time: 1260\n  meta_info:\n    min_slots_per_day: 0\n    max_slots_per_day: 3\n    setpoint_required_per_slot: false\n\ntime_program_circulation_pump: \n  extra_fields: {}\n  monday: []\n  tuesday: []\n  wednesday: []\n  thursday: []\n  friday: []\n  saturday: []\n  sunday: []\n  meta_info:\n    min_slots_per_day: 0\n    max_slots_per_day: 3\n    setpoint_required_per_slot: false\n</code></pre>"},{"location":"2-library/","title":"CLI &amp; Python Library","text":"<p>The myPyllant library can interact with the API behind the myVAILLANT app  (and branded versions of it, such as the MiGo app from Saunier Duval). Needs at least Python 3.10.</p> <p>Not affiliated with Vaillant, the developers take no responsibility for anything that happens to your devices because of this library.</p>"},{"location":"2-library/#installation","title":"Installation","text":"<p>Warning</p> <p>You need at least Python 3.10</p> <pre><code>pip install myPyllant\npython3 -m myPyllant.export user password brand --country country\n# See python3 -m myPyllant.export -h for more options and a list of countries\n</code></pre> <p>..or use Docker:</p> <pre><code>docker run -ti ghcr.io/signalkraft/mypyllant:latest python3 -m myPyllant.export user password brand --country country\n</code></pre> <p>The <code>--data</code> argument exports historical data of the devices in your system. Without this keyword, information about your system will be exported as JSON.</p>"},{"location":"2-library/#usage","title":"Usage","text":""},{"location":"2-library/#exporting-data-about-your-system","title":"Exporting Data about your System","text":"<pre><code>python3 -m myPyllant.export user password brand --country country\n# See python3 -m myPyllant.export -h for more options and a list of countries\n</code></pre> <p>The <code>--data</code> argument exports historical data of the devices in your system. Without this keyword, information about your system will be exported as JSON.</p> Source code in <code>myPyllant/export.py</code> <pre><code>async def main(\n    user,\n    password,\n    brand,\n    country=None,\n    data=False,\n    resolution=None,\n    start=None,\n    end=None,\n):\n    async with MyPyllantAPI(user, password, brand, country) as api:\n        export_list = []\n        async for system in api.get_systems(\n            include_connection_status=True,\n            include_diagnostic_trouble_codes=True,\n            include_rts=True,\n            include_mpc=True,\n        ):\n            if data:\n                for device in system.devices:\n                    data = [\n                        d.prepare_dict()\n                        async for d in api.get_data_by_device(\n                            device, resolution, start, end\n                        )\n                    ]\n                    export_list.append(dict(device=device.prepare_dict(), data=data))\n\n            else:\n                export_list.append(system.prepare_dict())\n\n        return export_list\n</code></pre>"},{"location":"2-library/#exporting-energy-reports","title":"Exporting Energy Reports","text":"<pre><code>python3 -m myPyllant.report user password brand --country country\n# Wrote 2023 report to energy_data_2023_ArothermPlus_XYZ.csv\n# Wrote 2023 report to energy_data_2023_HydraulicStation_XYZ.csv\n</code></pre> <p>Writes a report for each heat generator, by default for the current year. You can provide <code>--year</code> to select a different year.</p> Source code in <code>myPyllant/report.py</code> <pre><code>async def main(user, password, brand, year: int, country=None, write_results=True):\n    async with MyPyllantAPI(user, password, brand, country) as api:\n        async for system in api.get_systems():\n            reports = api.get_yearly_reports(system, year)\n            async for report in reports:\n                if write_results:\n                    with open(report.file_name, \"w\") as fh:\n                        fh.write(report.file_content)\n                    sys.stdout.write(f\"Wrote {year} report to {report.file_name}\\n\")\n                else:\n                    yield report\n</code></pre>"},{"location":"2-library/#using-the-api-in-python","title":"Using the API in Python","text":"<pre><code>#!/usr/bin/env python3\n\nimport argparse\nimport asyncio\nimport logging\nfrom datetime import datetime, timedelta\n\nfrom myPyllant.api import MyPyllantAPI\nfrom myPyllant.const import ALL_COUNTRIES, BRANDS, DEFAULT_BRAND\n\nparser = argparse.ArgumentParser(description=\"Export data from myVaillant API   .\")\nparser.add_argument(\"user\", help=\"Username (email address) for the myVaillant app\")\nparser.add_argument(\"password\", help=\"Password for the myVaillant app\")\nparser.add_argument(\n    \"brand\",\n    help=\"Brand your account is registered in, i.e. 'vaillant'\",\n    default=DEFAULT_BRAND,\n    choices=BRANDS.keys(),\n)\nparser.add_argument(\n    \"--country\",\n    help=\"Country your account is registered in, i.e. 'germany'\",\n    choices=ALL_COUNTRIES.keys(),\n    required=False,\n)\nparser.add_argument(\n    \"-v\", \"--verbose\", help=\"increase output verbosity\", action=\"store_true\"\n)\n\n\nasync def main(user, password, brand, country):\n    async with MyPyllantAPI(user, password, brand, country) as api:\n        async for system in api.get_systems():\n            print(await api.set_set_back_temperature(system.zones[0], 18))\n            print(await api.quick_veto_zone_temperature(system.zones[0], 21, 5))\n            print(await api.cancel_quick_veto_zone_temperature(system.zones[0]))\n            setpoint = 10.0 if system.control_identifier.is_vrc700 else None\n            print(\n                await api.set_holiday(\n                    system,\n                    datetime.now(system.timezone),\n                    datetime.now(system.timezone) + timedelta(days=7),\n                    setpoint,  # Setpoint is only required for VRC700 systems\n                )\n            )\n            print(await api.cancel_holiday(system))\n            if system.domestic_hot_water:\n                print(await api.boost_domestic_hot_water(system.domestic_hot_water[0]))\n                print(await api.cancel_hot_water_boost(system.domestic_hot_water[0]))\n                print(\n                    await api.set_domestic_hot_water_temperature(\n                        system.domestic_hot_water[0], 46\n                    )\n                )\n\n\nif __name__ == \"__main__\":\n    args = parser.parse_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(args.user, args.password, args.brand, args.country))\n</code></pre> <p>Want to contribute more features? Checkout out the contribution section.</p>"},{"location":"2-library/#api-documentation","title":"API Documentation","text":"Source code in <code>myPyllant/api.py</code> <pre><code>class MyPyllantAPI:\n    username: str\n    password: str\n    aiohttp_session: aiohttp.ClientSession\n    oauth_session: dict = {}\n    oauth_session_expires: datetime.datetime | None = None\n    control_identifiers: dict[str, str] = {}\n\n    def __init__(\n        self, username: str, password: str, brand: str, country: str | None = None\n    ) -&gt; None:\n        if brand not in BRANDS.keys():\n            raise ValueError(\n                f\"Invalid brand, must be one of {', '.join(BRANDS.keys())}\"\n            )\n        if brand in COUNTRIES:\n            # Only need to valid country, if the brand exists as a key in COUNTRIES\n            if not country:\n                raise RealmInvalid(f\"{BRANDS[brand]} requires country to be passed\")\n            elif country not in COUNTRIES[brand].keys():\n                raise RealmInvalid(\n                    f\"Invalid country, {BRANDS[brand]} only supports {', '.join(COUNTRIES[brand].keys())}\"\n                )\n\n        self.username = username\n        self.password = password\n        self.country = country\n        self.brand = brand\n\n        self.aiohttp_session = get_http_client()\n\n    async def __aenter__(self) -&gt; MyPyllantAPI:\n        try:\n            await self.login()\n        except Exception:\n            await self.aiohttp_session.close()\n            raise\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb) -&gt; None:\n        if not self.aiohttp_session.closed:\n            await self.aiohttp_session.close()\n\n    async def login(self):\n        code, code_verifier = await self.get_code()\n        self.oauth_session = await self.get_token(code, code_verifier)\n        logger.debug(\"Got session %s\", self.oauth_session)\n        self.set_session_expires()\n\n    async def get_code(self):\n        \"\"\"\n        This should really be done in the browser with OIDC, but that's not easy without support from Vaillant\n\n        So instead, we grab the login endpoint from the HTML form of the login website and send username + password\n        to obtain a session\n        \"\"\"\n\n        code_verifier, code_challenge = generate_code()\n        auth_querystring = {\n            \"response_type\": \"code\",\n            \"client_id\": CLIENT_ID,\n            \"code\": \"code_challenge\",\n            \"redirect_uri\": \"enduservaillant.page.link://login\",\n            \"code_challenge_method\": \"S256\",\n            \"code_challenge\": code_challenge,\n        }\n\n        # Grabbing the login URL from the HTML form of the login page\n        code = None\n        try:\n            async with self.aiohttp_session.get(\n                AUTHENTICATE_URL.format(realm=get_realm(self.brand, self.country))\n                + \"?\"\n                + urlencode(auth_querystring),\n                allow_redirects=False,\n            ) as resp:\n                login_html = await resp.text()\n                if \"Location\" in resp.headers:\n                    parsed_url = urlparse(resp.headers[\"Location\"])\n                    code = parse_qs(parsed_url.query).get(\"code\")\n        except ClientResponseError as e:\n            raise LoginEndpointInvalid from e\n\n        if not code:\n            result = re.search(\n                LOGIN_URL.format(realm=get_realm(self.brand, self.country))\n                + r\"\\?([^\\\"]*)\",\n                login_html,\n            )\n            login_url = unescape(result.group()) if result else None\n            if not login_url:\n                raise AuthenticationFailed(\"Could not get login URL\")\n\n            logger.debug(\"Got login url %s\", login_url)\n            login_payload = {\n                \"username\": self.username,\n                \"password\": self.password,\n                \"credentialId\": \"\",\n            }\n            # Obtaining the code\n            async with self.aiohttp_session.post(\n                login_url, data=login_payload, allow_redirects=False\n            ) as resp:\n                logger.debug(\"Got login response headers %s\", resp.headers)\n                if \"Location\" not in resp.headers:\n                    raise AuthenticationFailed(\"Login failed\")\n                logger.debug(\n                    f'Got location from authorize endpoint: {resp.headers[\"Location\"]}'\n                )\n                parsed_url = urlparse(resp.headers[\"Location\"])\n                code = parse_qs(parsed_url.query)[\"code\"]\n        return code, code_verifier\n\n    async def get_token(self, code, code_verifier):\n        # Obtaining access token and refresh token\n        token_payload = {\n            \"grant_type\": \"authorization_code\",\n            \"client_id\": \"myvaillant\",\n            \"code\": code,\n            \"code_verifier\": code_verifier,\n            \"redirect_uri\": \"enduservaillant.page.link://login\",\n        }\n\n        async with self.aiohttp_session.post(\n            TOKEN_URL.format(realm=get_realm(self.brand, self.country)),\n            data=token_payload,\n            raise_for_status=False,\n        ) as resp:\n            login_json = await resp.json()\n            if resp.status &gt;= 400:\n                logger.error(\n                    f\"Could not log in, got status {resp.status} this response: {login_json}\"\n                )\n                raise Exception(login_json)\n            return login_json\n\n    def set_session_expires(self):\n        self.oauth_session_expires = datetime.datetime.now(\n            datetime.timezone.utc\n        ) + datetime.timedelta(seconds=self.oauth_session[\"expires_in\"])\n        logger.debug(\"Session expires in %s\", self.oauth_session_expires)\n\n    async def refresh_token(self):\n        refresh_payload = {\n            \"refresh_token\": self.oauth_session[\"refresh_token\"],\n            \"client_id\": CLIENT_ID,\n            \"grant_type\": \"refresh_token\",\n        }\n        async with self.aiohttp_session.post(\n            TOKEN_URL.format(realm=get_realm(self.brand, self.country)),\n            data=refresh_payload,\n        ) as resp:\n            self.oauth_session = await resp.json()\n            self.set_session_expires()\n            return self.oauth_session\n\n    @property\n    def access_token(self):\n        return self.oauth_session[\"access_token\"]\n\n    def get_authorized_headers(self):\n        return {\n            \"Authorization\": \"Bearer \" + self.access_token,\n            \"x-app-identifier\": \"VAILLANT\",\n            \"Accept-Language\": \"en-GB\",\n            \"Accept\": \"application/json, text/plain, */*\",\n            \"x-client-locale\": \"en-GB\",\n            \"x-idm-identifier\": \"KEYCLOAK\",\n            \"ocp-apim-subscription-key\": \"1e0a2f3511fb4c5bbb1c7f9fedd20b1c\",\n            \"User-Agent\": \"okhttp/4.9.2\",\n            \"Connection\": \"keep-alive\",\n        }\n\n    async def get_api_base(\n        self,\n        system: str | System | None = None,\n        control_identifier: ControlIdentifier | str | None = None,\n        systems: bool = False,\n    ) -&gt; str:\n        if system and not control_identifier:\n            control_identifier = await self.get_control_identifier(system)\n        return get_api_base(control_identifier, systems)\n\n    async def get_system_api_base(\n        self,\n        system: str | System,\n        control_identifier: ControlIdentifier | str | None = None,\n        systems: bool = False,\n    ) -&gt; str:\n        if not control_identifier:\n            control_identifier = await self.get_control_identifier(system)\n        suffix = \"\"\n        if control_identifier == ControlIdentifier.TLI:\n            suffix = \"/tli\"\n        return f\"{await self.get_api_base(system, control_identifier, systems)}/systems/{get_system_id(system)}{suffix}\"\n\n    async def get_homes(self) -&gt; AsyncIterator[Home]:\n        \"\"\"\n        Returns configured homes and their system IDs\n\n        Returns:\n            An Async Iterator with all the configured `Home` objects for the logged-in user\n        \"\"\"\n        async with self.aiohttp_session.get(\n            f\"{await self.get_api_base()}/homes\", headers=self.get_authorized_headers()\n        ) as homes_resp:\n            for home_json in dict_to_snake_case(await homes_resp.json()):\n                if \"system_id\" not in home_json or not home_json[\"system_id\"]:\n                    logger.warning(\n                        \"Skipping home because system_id is missing or empty: %s\",\n                        home_json,\n                    )\n                    continue\n                timezone = await self.get_time_zone(home_json[\"system_id\"])\n                yield Home.from_api(timezone=timezone, **home_json)\n\n    async def get_systems(\n        self,\n        include_connection_status: bool = False,\n        include_diagnostic_trouble_codes: bool = False,\n        include_rts: bool = False,\n        include_mpc: bool = False,\n    ) -&gt; AsyncIterator[System]:\n        \"\"\"\n        Returns an async generator of systems under control of the user\n\n        Parameters:\n            include_connection_status: Fetches connection status for each system\n            include_diagnostic_trouble_codes: Fetches diagnostic trouble codes for each system and device\n            include_rts: Fetches RTS data for each system, only supported on TLI controllers\n            include_mpc: Fetches MPC data for each system, only supported on TLI controllers\n\n        Returns:\n            An Async Iterator with all the `System` objects\n\n        Examples:\n            &gt;&gt;&gt; async for system in MyPyllantAPI(**kwargs).get_systems():\n            &gt;&gt;&gt;    print(system.water_pressure)\n        \"\"\"\n        homes = self.get_homes()\n        async for home in homes:\n            control_identifier = await self.get_control_identifier(home.system_id)\n            if control_identifier.is_vrc700:\n                if include_rts:\n                    include_rts = False\n                    logger.info(\n                        \"Fetching RTS data is not supported on VRC700 controllers\"\n                    )\n                if include_mpc:\n                    include_mpc = False\n                    logger.info(\n                        \"Fetching MPC data is not supported on VRC700 controllers\"\n                    )\n            system_url = await self.get_system_api_base(home.system_id, systems=True)\n            current_system_url = (\n                f\"{await self.get_api_base()}/emf/v2/{home.system_id}/currentSystem\"\n            )\n\n            async with self.aiohttp_session.get(\n                system_url, headers=self.get_authorized_headers()\n            ) as system_resp:\n                system_raw = await system_resp.text()\n                if control_identifier.is_vrc700:\n                    system_raw = system_raw.replace(\"domesticHotWater\", \"dhw\")\n                    system_raw = system_raw.replace(\"DomesticHotWater\", \"Dhw\")\n                system_json = dict_to_snake_case(json.loads(system_raw))\n\n            async with self.aiohttp_session.get(\n                current_system_url, headers=self.get_authorized_headers()\n            ) as current_system_resp:\n                current_system_json = await current_system_resp.json()\n\n            system = System.from_api(\n                brand=self.brand,\n                home=home,\n                timezone=home.timezone,\n                control_identifier=control_identifier,\n                connected=await self.get_connection_status(home.system_id)\n                if include_connection_status\n                else None,\n                diagnostic_trouble_codes=await self.get_diagnostic_trouble_codes(\n                    home.system_id\n                )\n                if include_diagnostic_trouble_codes\n                else None,\n                rts=await self.get_rts(home.system_id) if include_rts else {},\n                mpc=await self.get_mpc(home.system_id) if include_mpc else {},\n                current_system=dict_to_snake_case(current_system_json),\n                **dict_to_snake_case(system_json),\n            )\n            yield system\n\n    async def get_data_by_device(\n        self,\n        device: Device,\n        data_resolution: DeviceDataBucketResolution = DeviceDataBucketResolution.DAY,\n        data_from: datetime.datetime | None = None,\n        data_to: datetime.datetime | None = None,\n    ) -&gt; AsyncIterator[DeviceData]:\n        \"\"\"\n        Gets all energy data for a device\n\n        Parameters:\n            device: The device\n            data_resolution: Which resolution level (i.e. day, month)\n            data_from: Starting datetime\n            data_to: End datetime\n\n        \"\"\"\n        for data in device.data:\n            data_from = data_from or data.data_from\n            if not data_from:\n                raise ValueError(\n                    \"No data_from set, and no data_from found in device data\"\n                )\n            data_to = data_to or data.data_to\n            if not data_to:\n                raise ValueError(\"No data_to set, and no data_to found in device data\")\n            start_date = datetime_format(data_from)\n            end_date = datetime_format(data_to)\n            querystring = {\n                \"resolution\": str(data_resolution),\n                \"operationMode\": data.operation_mode,\n                \"energyType\": data.value_type,\n                \"startDate\": start_date,\n                \"endDate\": end_date,\n            }\n            device_buckets_url = (\n                f\"{await self.get_api_base()}/emf/v2/{device.system_id}/\"\n                f\"devices/{device.device_uuid}/buckets?{urlencode(querystring)}\"\n            )\n            async with self.aiohttp_session.get(\n                device_buckets_url, headers=self.get_authorized_headers()\n            ) as device_buckets_resp:\n                device_buckets_json = await device_buckets_resp.json()\n                yield DeviceData.from_api(\n                    timezone=device.timezone,\n                    device=device,\n                    **dict_to_snake_case(device_buckets_json),\n                )\n\n    async def get_yearly_reports(\n        self,\n        system: System,\n        year: int | None = None,\n    ) -&gt; AsyncIterator[SystemReport]:\n        \"\"\"\n        Returns an async generator of systems under control of the user\n\n        Parameters:\n            system: The System object or system ID string\n            year: The year of the report\n        \"\"\"\n        url = f\"{await self.get_api_base()}/emf/v2/{system.id}/report/{year}\"\n        async with self.aiohttp_session.get(\n            url, headers=self.get_authorized_headers()\n        ) as report_resp:\n            reports_json = await report_resp.json()\n            for report in dict_to_snake_case(reports_json):\n                yield SystemReport.from_api(**report)\n\n    async def set_zone_operating_mode(\n        self,\n        zone: Zone,\n        mode: ZoneHeatingOperatingMode | ZoneHeatingOperatingModeVRC700,\n        operating_type: str = \"heating\",\n    ):\n        \"\"\"\n        Sets the operating mode for a zone\n\n        Parameters:\n            zone: The target zone\n            mode: The target operating mode\n            operating_type: Either heating or cooling\n        \"\"\"\n        if operating_type not in ZONE_OPERATING_TYPES:\n            raise ValueError(\n                f\"Invalid HVAC mode, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n            )\n        if zone.control_identifier.is_vrc700:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/heating/operation-mode\"\n            key = \"operationMode\"\n            mode_enum = ZoneHeatingOperatingModeVRC700  # type: ignore\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/{operating_type}-operation-mode\"\n            key = f\"{operating_type}OperationMode\"\n            mode_enum = ZoneHeatingOperatingMode  # type: ignore\n\n        if mode not in mode_enum:\n            raise ValueError(\n                f\"Invalid mode, must be one of {', '.join(mode_enum.__members__)}\"\n            )\n\n        return await self.aiohttp_session.patch(\n            url,\n            json={key: str(mode)},\n            headers=self.get_authorized_headers(),\n        )\n\n    async def quick_veto_zone_temperature(\n        self,\n        zone: Zone,\n        temperature: float,\n        duration_hours: float | None = None,\n        default_duration: float | None = None,\n        veto_type: str = \"heating\",\n    ):\n        \"\"\"\n        Temporarily overwrites the desired temperature in a zone\n\n        Parameters:\n            zone: The target zone\n            temperature: The target temperature\n            duration_hours: Optional, sets overwrite for this many hours\n            default_duration: Optional, falls back to this default duration if duration_hours is not given\n            veto_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if not default_duration:\n            default_duration = DEFAULT_QUICK_VETO_DURATION\n        if zone.control_identifier.is_vrc700:\n            if veto_type not in ZONE_OPERATING_TYPES:\n                raise ValueError(\n                    f\"Invalid veto type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n        if zone.current_special_function == ZoneCurrentSpecialFunction.QUICK_VETO:\n            logger.debug(\n                f\"Patching quick veto for {zone.name} because it is already in quick veto mode\"\n            )\n            payload = {\n                \"desiredRoomTemperatureSetpoint\": temperature,\n            }\n            if duration_hours:\n                payload[\"duration\"] = duration_hours\n            return await self.aiohttp_session.patch(\n                url,\n                json=payload,\n                headers=self.get_authorized_headers(),\n            )\n        else:\n            return await self.aiohttp_session.post(\n                url,\n                json={\n                    \"desiredRoomTemperatureSetpoint\": temperature,\n                    \"duration\": duration_hours if duration_hours else default_duration,\n                },\n                headers=self.get_authorized_headers(),\n            )\n\n    async def quick_veto_zone_duration(\n        self,\n        zone: Zone,\n        duration_hours: float,\n        veto_type: str = \"heating\",\n    ):\n        \"\"\"\n        Updates the quick veto duration\n\n        Parameters:\n            zone: The target zone\n            duration_hours: Updates quick veto duration (in hours)\n            veto_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if zone.control_identifier.is_vrc700:\n            if veto_type not in ZONE_OPERATING_TYPES:\n                raise ValueError(\n                    f\"Invalid veto type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n        return await self.aiohttp_session.patch(\n            url,\n            json={\"duration\": duration_hours},\n            headers=self.get_authorized_headers(),\n        )\n\n    async def set_time_program_temperature(\n        self,\n        zone: Zone,\n        program_type: str,\n        temperature: float,\n        update_similar_to_dow: str | None = None,\n    ):\n        logger.debug(f\"Setting time program temp {zone.name}\")\n\n        if program_type not in ZoneTimeProgramType:\n            raise ValueError(\n                \"Type must be either heating or cooling, not %s\", program_type\n            )\n\n        time_program = zone.heating.time_program_heating\n        time_program.set_setpoint(temperature, update_similar_to_dow)\n        return await self.set_zone_time_program(zone, program_type, time_program)\n\n    async def set_manual_mode_setpoint(\n        self,\n        zone: Zone,\n        temperature: float,\n        setpoint_type: str = \"HEATING\",\n    ):\n        \"\"\"\n        Sets the desired temperature when in manual mode\n\n        Parameters:\n            zone: The target zone\n            temperature: The target temperature\n            setpoint_type: Either HEATING or COOLING\n        \"\"\"\n        logger.debug(\"Setting manual mode setpoint for %s\", zone.name)\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/manual-mode-setpoint\"\n        payload = {\n            \"setpoint\": temperature,\n            \"type\": setpoint_type,\n        }\n        return await self.aiohttp_session.patch(\n            url,\n            json=payload,\n            headers=self.get_authorized_headers(),\n        )\n\n    async def cancel_quick_veto_zone_temperature(\n        self, zone: Zone, veto_type: str = \"heating\"\n    ):\n        \"\"\"\n        Cancels a previously set quick veto in a zone\n\n        Parameters:\n            zone: The target zone\n            veto_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if zone.control_identifier.is_vrc700:\n            if veto_type not in ZONE_OPERATING_TYPES:\n                raise ValueError(\n                    f\"Invalid veto type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n        return await self.aiohttp_session.delete(\n            url, headers=self.get_authorized_headers()\n        )\n\n    async def set_set_back_temperature(\n        self, zone: Zone, temperature: float, setback_type: str = \"heating\"\n    ):\n        \"\"\"\n        Sets the temperature that a zone gets lowered to in away mode\n\n        Parameters:\n            zone: The target zone\n            temperature: The setback temperature\n            setback_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if zone.control_identifier.is_vrc700:\n            if setback_type not in ZONE_OPERATING_TYPES:\n                raise ValueError(\n                    f\"Invalid setback type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setback_type}/set-back-temperature\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/set-back-temperature\"\n        return await self.aiohttp_session.patch(\n            url,\n            json={\"setBackTemperature\": temperature},\n            headers=self.get_authorized_headers(),\n        )\n\n    async def set_zone_time_program(\n        self,\n        zone: Zone,\n        program_type: str,\n        time_program: ZoneTimeProgram,\n        setback_type: str = \"heating\",\n    ):\n        \"\"\"\n        Sets the temperature that a zone gets lowered to in away mode\n\n        Parameters:\n            zone: The target zone\n            program_type: Which program to set\n            time_program: The time schedule\n            setback_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if program_type not in ZoneTimeProgramType:\n            raise ValueError(\n                \"Type must be either heating or cooling, not %s\", program_type\n            )\n        if zone.control_identifier.is_vrc700:\n            if setback_type not in ZONE_OPERATING_TYPES:\n                raise ValueError(\n                    f\"Invalid veto type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setback_type}/time-windows\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/time-windows\"\n        data = asdict(time_program)\n        data[\"type\"] = program_type\n        del data[\"meta_info\"]\n        return await self.aiohttp_session.patch(\n            url,\n            json=dict_to_camel_case(data),\n            headers=self.get_authorized_headers(),\n        )\n\n    async def set_holiday(\n        self,\n        system: System,\n        start: datetime.datetime | None = None,\n        end: datetime.datetime | None = None,\n        setpoint: float | None = None,\n    ):\n        \"\"\"\n        Sets away mode / holiday mode on a system\n\n        Parameters:\n            system: The target system\n            start: Optional, datetime when the system goes into away mode. Defaults to now\n            end: Optional, datetime when away mode should end. Defaults to one year from now\n            setpoint: Optional, setpoint temperature during holiday, only supported on VRC700 controllers\n        \"\"\"\n        start, end = get_default_holiday_dates(start, end, system.timezone)\n        logger.debug(\n            \"Setting holiday mode for system %s to %s - %s\", system.id, start, end\n        )\n        if not start &lt;= end:\n            raise ValueError(\"Start of holiday mode must be before end\")\n\n        data = {\n            \"startDateTime\": datetime_format(start, with_microseconds=True),\n            \"endDateTime\": datetime_format(end, with_microseconds=True),\n        }\n\n        if system.control_identifier.is_vrc700:\n            url = f\"{await self.get_system_api_base(system.id)}/holiday\"\n            if setpoint is None:\n                raise ValueError(\"setpoint is required on this controller\")\n            data[\"setpoint\"] = setpoint  # type: ignore\n        else:\n            url = f\"{await self.get_system_api_base(system.id)}/away-mode\"\n            if setpoint is not None:\n                raise ValueError(\"setpoint is not supported on this controller\")\n\n        return await self.aiohttp_session.post(\n            url, json=data, headers=self.get_authorized_headers()\n        )\n\n    async def cancel_holiday(self, system: System):\n        \"\"\"\n        Cancels a previously set away mode / holiday mode on a system\n\n        Parameters:\n            system: The target system\n        \"\"\"\n        if system.control_identifier.is_vrc700:\n            url = f\"{await self.get_system_api_base(system.id)}/holiday\"\n        else:\n            url = f\"{await self.get_system_api_base(system.id)}/away-mode\"\n\n        if system.zones and system.zones[0].general.holiday_start_in_future:\n            # For some reason cancelling holidays in the future doesn't work, but setting a past value does\n            default_holiday = datetime.datetime(2019, 1, 1, 0, 0, 0)\n            return await self.set_holiday(\n                system, start=default_holiday, end=default_holiday\n            )\n        else:\n            return await self.aiohttp_session.delete(\n                url, headers=self.get_authorized_headers()\n            )\n\n    async def set_domestic_hot_water_temperature(\n        self, domestic_hot_water: DomesticHotWater, temperature: int | float\n    ):\n        \"\"\"\n        Sets the desired hot water temperature\n\n        Parameters:\n            domestic_hot_water: The water heater\n            temperature: The desired temperature, only whole numbers are supported by the API, floats get rounded\n        \"\"\"\n        if isinstance(temperature, float):\n            logger.warning(\"Domestic hot water can only be set to whole numbers\")\n            temperature = int(round(temperature, 0))\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/temperature\"\n        )\n        return await self.aiohttp_session.patch(\n            url, json={\"setpoint\": temperature}, headers=self.get_authorized_headers()\n        )\n\n    async def boost_domestic_hot_water(self, domestic_hot_water: DomesticHotWater):\n        \"\"\"\n        Temporarily boosts hot water temperature\n\n        Parameters:\n            domestic_hot_water: The water heater\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/boost\"\n        )\n        return await self.aiohttp_session.post(\n            url, json={}, headers=self.get_authorized_headers()\n        )\n\n    async def cancel_hot_water_boost(self, domestic_hot_water: DomesticHotWater):\n        \"\"\"\n        Cancels hot water boost\n\n        Parameters:\n            domestic_hot_water: The water heater\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/boost\"\n        )\n        return await self.aiohttp_session.delete(\n            url, headers=self.get_authorized_headers()\n        )\n\n    async def set_domestic_hot_water_operation_mode(\n        self,\n        domestic_hot_water: DomesticHotWater,\n        mode: DHWOperationMode | DHWOperationModeVRC700,\n    ):\n        \"\"\"\n        Sets the operation mode for water heating\n\n        Parameters:\n            domestic_hot_water: The water heater\n            mode: The operation mode\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}/domestic-hot-water/\"\n            f\"{domestic_hot_water.index}/operation-mode\"\n        )\n        return await self.aiohttp_session.patch(\n            url,\n            json={\"operationMode\": str(mode)},\n            headers=self.get_authorized_headers(),\n        )\n\n    async def set_domestic_hot_water_time_program(\n        self, domestic_hot_water: DomesticHotWater, time_program: DHWTimeProgram\n    ):\n        \"\"\"\n        Sets the schedule for heating water\n\n        Parameters:\n            domestic_hot_water: The water heater\n            time_program: The schedule\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/time-windows\"\n        )\n        data = asdict(time_program)\n        del data[\"meta_info\"]\n        return await self.aiohttp_session.patch(\n            url,\n            json=dict_to_camel_case(data),\n            headers=self.get_authorized_headers(),\n        )\n\n    async def set_domestic_hot_water_circulation_time_program(\n        self, domestic_hot_water: DomesticHotWater, time_program: DHWTimeProgram\n    ):\n        \"\"\"\n        Sets the schedule for the water circulation pump\n\n        Parameters:\n            domestic_hot_water: The water heater\n            time_program: The schedule\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/circulation-pump-time-windows\"\n        )\n        data = asdict(time_program)\n        del data[\"meta_info\"]\n        return await self.aiohttp_session.patch(\n            url,\n            json=dict_to_camel_case(data),\n            headers=self.get_authorized_headers(),\n        )\n\n    async def set_ventilation_operation_mode(\n        self, ventilation: Ventilation, mode: VentilationOperationMode\n    ):\n        \"\"\"\n        Sets the operation mode for a ventilation device\n\n        Parameters:\n            ventilation: The ventilation device\n            mode: The operation mode\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(ventilation.system_id)}\"\n            f\"/ventilation/{ventilation.index}/operation-mode\"\n        )\n        return await self.aiohttp_session.patch(\n            url,\n            json={\n                \"operationMode\": str(mode),\n            },\n            headers=self.get_authorized_headers(),\n        )\n\n    async def set_ventilation_fan_stage(\n        self,\n        ventilation: Ventilation,\n        maximum_fan_stage: int,\n        fan_stage_type: VentilationFanStageType,\n    ):\n        \"\"\"\n        Sets the maximum fan stage for a stage type\n\n        Parameters:\n            ventilation: The ventilation device\n            maximum_fan_stage: The maximum fan speed, from 1-6\n            fan_stage_type: The fan stage type (day or night)\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(ventilation.system_id)}\"\n            f\"/ventilation/{ventilation.index}/fan-stage\"\n        )\n        return await self.aiohttp_session.patch(\n            url,\n            json={\n                \"maximumFanStage\": maximum_fan_stage,\n                \"type\": str(fan_stage_type),\n            },\n            headers=self.get_authorized_headers(),\n        )\n\n    async def get_connection_status(self, system: System | str) -&gt; bool:\n        \"\"\"\n        Returns whether the system is online\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = (\n            f\"{await self.get_api_base()}/systems/\"\n            f\"{get_system_id(system)}/meta-info/connection-status\"\n        )\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n        try:\n            return (await response.json())[\"connected\"]\n        except KeyError:\n            logger.warning(\"Couldn't get connection status\")\n            return False\n\n    async def get_control_identifier(self, system: System | str) -&gt; ControlIdentifier:\n        \"\"\"\n        The control identifier is used in the URL to request system information (usually `tli`)\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        system_id = get_system_id(system)\n\n        if system_id in self.control_identifiers:\n            # We already have the control identifier cached\n            control_identifier = self.control_identifiers[system_id]\n        else:\n            url = (\n                f\"{await self.get_api_base()}/systems/\"\n                f\"{system_id}/meta-info/control-identifier\"\n            )\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n            try:\n                control_identifier = (await response.json())[\"controlIdentifier\"]\n                self.control_identifiers[system_id] = control_identifier\n            except KeyError:\n                logger.warning(\"Couldn't get control identifier\")\n                control_identifier = DEFAULT_CONTROL_IDENTIFIER\n\n        return ControlIdentifier(control_identifier)\n\n    async def get_time_zone(self, system: System | str) -&gt; datetime.tzinfo | None:\n        \"\"\"\n        Gets the configured timezone for a system\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = (\n            f\"{await self.get_api_base()}/systems/\"\n            f\"{get_system_id(system)}/meta-info/time-zone\"\n        )\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n        try:\n            tz = (await response.json())[\"timeZone\"]\n            return gettz(tz)\n        except KeyError:\n            logger.warning(\"Couldn't get timezone from API\")\n            return None\n\n    async def get_diagnostic_trouble_codes(\n        self, system: System | str\n    ) -&gt; list[dict] | None:\n        \"\"\"\n        Returns a list of trouble codes by device\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = (\n            f\"{await self.get_api_base()}/systems/\"\n            f\"{get_system_id(system)}/diagnostic-trouble-codes\"\n        )\n        try:\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get diagnostic trouble codes\", exc_info=e)\n            return None\n        result = await response.json()\n        return dict_to_snake_case(result)\n\n    async def get_rts(self, system: System | str) -&gt; dict:\n        \"\"\"\n        Gets RTS data, which contains on/off cycles and operation time\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = f\"{await self.get_api_base(system)}/rts/{get_system_id(system)}/devices\"\n        try:\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get RTS data\", exc_info=e)\n            return {}\n        result = await response.json()\n        return dict_to_snake_case(result)\n\n    async def get_mpc(self, system: System | str) -&gt; dict:\n        \"\"\"\n        Gets MPC data. What is MPC data? No idea, I just saw it getting requested by the app. It seems to be empty?\n\n        TODO: Figure out what this is\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = f\"{await self.get_api_base(system)}/hem/{get_system_id(system)}/mpc\"\n        try:\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get MPC data\", exc_info=e)\n            return {}\n        result = await response.json()\n        return dict_to_snake_case(result)\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.boost_domestic_hot_water","title":"<code>boost_domestic_hot_water(domestic_hot_water)</code>  <code>async</code>","text":"<p>Temporarily boosts hot water temperature</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def boost_domestic_hot_water(self, domestic_hot_water: DomesticHotWater):\n    \"\"\"\n    Temporarily boosts hot water temperature\n\n    Parameters:\n        domestic_hot_water: The water heater\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/boost\"\n    )\n    return await self.aiohttp_session.post(\n        url, json={}, headers=self.get_authorized_headers()\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.cancel_holiday","title":"<code>cancel_holiday(system)</code>  <code>async</code>","text":"<p>Cancels a previously set away mode / holiday mode on a system</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The target system</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def cancel_holiday(self, system: System):\n    \"\"\"\n    Cancels a previously set away mode / holiday mode on a system\n\n    Parameters:\n        system: The target system\n    \"\"\"\n    if system.control_identifier.is_vrc700:\n        url = f\"{await self.get_system_api_base(system.id)}/holiday\"\n    else:\n        url = f\"{await self.get_system_api_base(system.id)}/away-mode\"\n\n    if system.zones and system.zones[0].general.holiday_start_in_future:\n        # For some reason cancelling holidays in the future doesn't work, but setting a past value does\n        default_holiday = datetime.datetime(2019, 1, 1, 0, 0, 0)\n        return await self.set_holiday(\n            system, start=default_holiday, end=default_holiday\n        )\n    else:\n        return await self.aiohttp_session.delete(\n            url, headers=self.get_authorized_headers()\n        )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.cancel_hot_water_boost","title":"<code>cancel_hot_water_boost(domestic_hot_water)</code>  <code>async</code>","text":"<p>Cancels hot water boost</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def cancel_hot_water_boost(self, domestic_hot_water: DomesticHotWater):\n    \"\"\"\n    Cancels hot water boost\n\n    Parameters:\n        domestic_hot_water: The water heater\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/boost\"\n    )\n    return await self.aiohttp_session.delete(\n        url, headers=self.get_authorized_headers()\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.cancel_quick_veto_zone_temperature","title":"<code>cancel_quick_veto_zone_temperature(zone, veto_type='heating')</code>  <code>async</code>","text":"<p>Cancels a previously set quick veto in a zone</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>veto_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def cancel_quick_veto_zone_temperature(\n    self, zone: Zone, veto_type: str = \"heating\"\n):\n    \"\"\"\n    Cancels a previously set quick veto in a zone\n\n    Parameters:\n        zone: The target zone\n        veto_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if zone.control_identifier.is_vrc700:\n        if veto_type not in ZONE_OPERATING_TYPES:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n    return await self.aiohttp_session.delete(\n        url, headers=self.get_authorized_headers()\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_code","title":"<code>get_code()</code>  <code>async</code>","text":"<p>This should really be done in the browser with OIDC, but that's not easy without support from Vaillant</p> <p>So instead, we grab the login endpoint from the HTML form of the login website and send username + password to obtain a session</p> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_code(self):\n    \"\"\"\n    This should really be done in the browser with OIDC, but that's not easy without support from Vaillant\n\n    So instead, we grab the login endpoint from the HTML form of the login website and send username + password\n    to obtain a session\n    \"\"\"\n\n    code_verifier, code_challenge = generate_code()\n    auth_querystring = {\n        \"response_type\": \"code\",\n        \"client_id\": CLIENT_ID,\n        \"code\": \"code_challenge\",\n        \"redirect_uri\": \"enduservaillant.page.link://login\",\n        \"code_challenge_method\": \"S256\",\n        \"code_challenge\": code_challenge,\n    }\n\n    # Grabbing the login URL from the HTML form of the login page\n    code = None\n    try:\n        async with self.aiohttp_session.get(\n            AUTHENTICATE_URL.format(realm=get_realm(self.brand, self.country))\n            + \"?\"\n            + urlencode(auth_querystring),\n            allow_redirects=False,\n        ) as resp:\n            login_html = await resp.text()\n            if \"Location\" in resp.headers:\n                parsed_url = urlparse(resp.headers[\"Location\"])\n                code = parse_qs(parsed_url.query).get(\"code\")\n    except ClientResponseError as e:\n        raise LoginEndpointInvalid from e\n\n    if not code:\n        result = re.search(\n            LOGIN_URL.format(realm=get_realm(self.brand, self.country))\n            + r\"\\?([^\\\"]*)\",\n            login_html,\n        )\n        login_url = unescape(result.group()) if result else None\n        if not login_url:\n            raise AuthenticationFailed(\"Could not get login URL\")\n\n        logger.debug(\"Got login url %s\", login_url)\n        login_payload = {\n            \"username\": self.username,\n            \"password\": self.password,\n            \"credentialId\": \"\",\n        }\n        # Obtaining the code\n        async with self.aiohttp_session.post(\n            login_url, data=login_payload, allow_redirects=False\n        ) as resp:\n            logger.debug(\"Got login response headers %s\", resp.headers)\n            if \"Location\" not in resp.headers:\n                raise AuthenticationFailed(\"Login failed\")\n            logger.debug(\n                f'Got location from authorize endpoint: {resp.headers[\"Location\"]}'\n            )\n            parsed_url = urlparse(resp.headers[\"Location\"])\n            code = parse_qs(parsed_url.query)[\"code\"]\n    return code, code_verifier\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_connection_status","title":"<code>get_connection_status(system)</code>  <code>async</code>","text":"<p>Returns whether the system is online</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_connection_status(self, system: System | str) -&gt; bool:\n    \"\"\"\n    Returns whether the system is online\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = (\n        f\"{await self.get_api_base()}/systems/\"\n        f\"{get_system_id(system)}/meta-info/connection-status\"\n    )\n    response = await self.aiohttp_session.get(\n        url,\n        headers=self.get_authorized_headers(),\n    )\n    try:\n        return (await response.json())[\"connected\"]\n    except KeyError:\n        logger.warning(\"Couldn't get connection status\")\n        return False\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_control_identifier","title":"<code>get_control_identifier(system)</code>  <code>async</code>","text":"<p>The control identifier is used in the URL to request system information (usually <code>tli</code>)</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_control_identifier(self, system: System | str) -&gt; ControlIdentifier:\n    \"\"\"\n    The control identifier is used in the URL to request system information (usually `tli`)\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    system_id = get_system_id(system)\n\n    if system_id in self.control_identifiers:\n        # We already have the control identifier cached\n        control_identifier = self.control_identifiers[system_id]\n    else:\n        url = (\n            f\"{await self.get_api_base()}/systems/\"\n            f\"{system_id}/meta-info/control-identifier\"\n        )\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n        try:\n            control_identifier = (await response.json())[\"controlIdentifier\"]\n            self.control_identifiers[system_id] = control_identifier\n        except KeyError:\n            logger.warning(\"Couldn't get control identifier\")\n            control_identifier = DEFAULT_CONTROL_IDENTIFIER\n\n    return ControlIdentifier(control_identifier)\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_data_by_device","title":"<code>get_data_by_device(device, data_resolution=DeviceDataBucketResolution.DAY, data_from=None, data_to=None)</code>  <code>async</code>","text":"<p>Gets all energy data for a device</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The device</p> required <code>data_resolution</code> <code>DeviceDataBucketResolution</code> <p>Which resolution level (i.e. day, month)</p> <code>DAY</code> <code>data_from</code> <code>datetime | None</code> <p>Starting datetime</p> <code>None</code> <code>data_to</code> <code>datetime | None</code> <p>End datetime</p> <code>None</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_data_by_device(\n    self,\n    device: Device,\n    data_resolution: DeviceDataBucketResolution = DeviceDataBucketResolution.DAY,\n    data_from: datetime.datetime | None = None,\n    data_to: datetime.datetime | None = None,\n) -&gt; AsyncIterator[DeviceData]:\n    \"\"\"\n    Gets all energy data for a device\n\n    Parameters:\n        device: The device\n        data_resolution: Which resolution level (i.e. day, month)\n        data_from: Starting datetime\n        data_to: End datetime\n\n    \"\"\"\n    for data in device.data:\n        data_from = data_from or data.data_from\n        if not data_from:\n            raise ValueError(\n                \"No data_from set, and no data_from found in device data\"\n            )\n        data_to = data_to or data.data_to\n        if not data_to:\n            raise ValueError(\"No data_to set, and no data_to found in device data\")\n        start_date = datetime_format(data_from)\n        end_date = datetime_format(data_to)\n        querystring = {\n            \"resolution\": str(data_resolution),\n            \"operationMode\": data.operation_mode,\n            \"energyType\": data.value_type,\n            \"startDate\": start_date,\n            \"endDate\": end_date,\n        }\n        device_buckets_url = (\n            f\"{await self.get_api_base()}/emf/v2/{device.system_id}/\"\n            f\"devices/{device.device_uuid}/buckets?{urlencode(querystring)}\"\n        )\n        async with self.aiohttp_session.get(\n            device_buckets_url, headers=self.get_authorized_headers()\n        ) as device_buckets_resp:\n            device_buckets_json = await device_buckets_resp.json()\n            yield DeviceData.from_api(\n                timezone=device.timezone,\n                device=device,\n                **dict_to_snake_case(device_buckets_json),\n            )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_diagnostic_trouble_codes","title":"<code>get_diagnostic_trouble_codes(system)</code>  <code>async</code>","text":"<p>Returns a list of trouble codes by device</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_diagnostic_trouble_codes(\n    self, system: System | str\n) -&gt; list[dict] | None:\n    \"\"\"\n    Returns a list of trouble codes by device\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = (\n        f\"{await self.get_api_base()}/systems/\"\n        f\"{get_system_id(system)}/diagnostic-trouble-codes\"\n    )\n    try:\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get diagnostic trouble codes\", exc_info=e)\n        return None\n    result = await response.json()\n    return dict_to_snake_case(result)\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_homes","title":"<code>get_homes()</code>  <code>async</code>","text":"<p>Returns configured homes and their system IDs</p> <p>Returns:</p> Type Description <code>AsyncIterator[Home]</code> <p>An Async Iterator with all the configured <code>Home</code> objects for the logged-in user</p> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_homes(self) -&gt; AsyncIterator[Home]:\n    \"\"\"\n    Returns configured homes and their system IDs\n\n    Returns:\n        An Async Iterator with all the configured `Home` objects for the logged-in user\n    \"\"\"\n    async with self.aiohttp_session.get(\n        f\"{await self.get_api_base()}/homes\", headers=self.get_authorized_headers()\n    ) as homes_resp:\n        for home_json in dict_to_snake_case(await homes_resp.json()):\n            if \"system_id\" not in home_json or not home_json[\"system_id\"]:\n                logger.warning(\n                    \"Skipping home because system_id is missing or empty: %s\",\n                    home_json,\n                )\n                continue\n            timezone = await self.get_time_zone(home_json[\"system_id\"])\n            yield Home.from_api(timezone=timezone, **home_json)\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_mpc","title":"<code>get_mpc(system)</code>  <code>async</code>","text":"<p>Gets MPC data. What is MPC data? No idea, I just saw it getting requested by the app. It seems to be empty?</p> <p>TODO: Figure out what this is</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_mpc(self, system: System | str) -&gt; dict:\n    \"\"\"\n    Gets MPC data. What is MPC data? No idea, I just saw it getting requested by the app. It seems to be empty?\n\n    TODO: Figure out what this is\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = f\"{await self.get_api_base(system)}/hem/{get_system_id(system)}/mpc\"\n    try:\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get MPC data\", exc_info=e)\n        return {}\n    result = await response.json()\n    return dict_to_snake_case(result)\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_rts","title":"<code>get_rts(system)</code>  <code>async</code>","text":"<p>Gets RTS data, which contains on/off cycles and operation time</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_rts(self, system: System | str) -&gt; dict:\n    \"\"\"\n    Gets RTS data, which contains on/off cycles and operation time\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = f\"{await self.get_api_base(system)}/rts/{get_system_id(system)}/devices\"\n    try:\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get RTS data\", exc_info=e)\n        return {}\n    result = await response.json()\n    return dict_to_snake_case(result)\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_systems","title":"<code>get_systems(include_connection_status=False, include_diagnostic_trouble_codes=False, include_rts=False, include_mpc=False)</code>  <code>async</code>","text":"<p>Returns an async generator of systems under control of the user</p> <p>Parameters:</p> Name Type Description Default <code>include_connection_status</code> <code>bool</code> <p>Fetches connection status for each system</p> <code>False</code> <code>include_diagnostic_trouble_codes</code> <code>bool</code> <p>Fetches diagnostic trouble codes for each system and device</p> <code>False</code> <code>include_rts</code> <code>bool</code> <p>Fetches RTS data for each system, only supported on TLI controllers</p> <code>False</code> <code>include_mpc</code> <code>bool</code> <p>Fetches MPC data for each system, only supported on TLI controllers</p> <code>False</code> <p>Returns:</p> Type Description <code>AsyncIterator[System]</code> <p>An Async Iterator with all the <code>System</code> objects</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async for system in MyPyllantAPI(**kwargs).get_systems():\n&gt;&gt;&gt;    print(system.water_pressure)\n</code></pre> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_systems(\n    self,\n    include_connection_status: bool = False,\n    include_diagnostic_trouble_codes: bool = False,\n    include_rts: bool = False,\n    include_mpc: bool = False,\n) -&gt; AsyncIterator[System]:\n    \"\"\"\n    Returns an async generator of systems under control of the user\n\n    Parameters:\n        include_connection_status: Fetches connection status for each system\n        include_diagnostic_trouble_codes: Fetches diagnostic trouble codes for each system and device\n        include_rts: Fetches RTS data for each system, only supported on TLI controllers\n        include_mpc: Fetches MPC data for each system, only supported on TLI controllers\n\n    Returns:\n        An Async Iterator with all the `System` objects\n\n    Examples:\n        &gt;&gt;&gt; async for system in MyPyllantAPI(**kwargs).get_systems():\n        &gt;&gt;&gt;    print(system.water_pressure)\n    \"\"\"\n    homes = self.get_homes()\n    async for home in homes:\n        control_identifier = await self.get_control_identifier(home.system_id)\n        if control_identifier.is_vrc700:\n            if include_rts:\n                include_rts = False\n                logger.info(\n                    \"Fetching RTS data is not supported on VRC700 controllers\"\n                )\n            if include_mpc:\n                include_mpc = False\n                logger.info(\n                    \"Fetching MPC data is not supported on VRC700 controllers\"\n                )\n        system_url = await self.get_system_api_base(home.system_id, systems=True)\n        current_system_url = (\n            f\"{await self.get_api_base()}/emf/v2/{home.system_id}/currentSystem\"\n        )\n\n        async with self.aiohttp_session.get(\n            system_url, headers=self.get_authorized_headers()\n        ) as system_resp:\n            system_raw = await system_resp.text()\n            if control_identifier.is_vrc700:\n                system_raw = system_raw.replace(\"domesticHotWater\", \"dhw\")\n                system_raw = system_raw.replace(\"DomesticHotWater\", \"Dhw\")\n            system_json = dict_to_snake_case(json.loads(system_raw))\n\n        async with self.aiohttp_session.get(\n            current_system_url, headers=self.get_authorized_headers()\n        ) as current_system_resp:\n            current_system_json = await current_system_resp.json()\n\n        system = System.from_api(\n            brand=self.brand,\n            home=home,\n            timezone=home.timezone,\n            control_identifier=control_identifier,\n            connected=await self.get_connection_status(home.system_id)\n            if include_connection_status\n            else None,\n            diagnostic_trouble_codes=await self.get_diagnostic_trouble_codes(\n                home.system_id\n            )\n            if include_diagnostic_trouble_codes\n            else None,\n            rts=await self.get_rts(home.system_id) if include_rts else {},\n            mpc=await self.get_mpc(home.system_id) if include_mpc else {},\n            current_system=dict_to_snake_case(current_system_json),\n            **dict_to_snake_case(system_json),\n        )\n        yield system\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_time_zone","title":"<code>get_time_zone(system)</code>  <code>async</code>","text":"<p>Gets the configured timezone for a system</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_time_zone(self, system: System | str) -&gt; datetime.tzinfo | None:\n    \"\"\"\n    Gets the configured timezone for a system\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = (\n        f\"{await self.get_api_base()}/systems/\"\n        f\"{get_system_id(system)}/meta-info/time-zone\"\n    )\n    response = await self.aiohttp_session.get(\n        url,\n        headers=self.get_authorized_headers(),\n    )\n    try:\n        tz = (await response.json())[\"timeZone\"]\n        return gettz(tz)\n    except KeyError:\n        logger.warning(\"Couldn't get timezone from API\")\n        return None\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.get_yearly_reports","title":"<code>get_yearly_reports(system, year=None)</code>  <code>async</code>","text":"<p>Returns an async generator of systems under control of the user</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The System object or system ID string</p> required <code>year</code> <code>int | None</code> <p>The year of the report</p> <code>None</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_yearly_reports(\n    self,\n    system: System,\n    year: int | None = None,\n) -&gt; AsyncIterator[SystemReport]:\n    \"\"\"\n    Returns an async generator of systems under control of the user\n\n    Parameters:\n        system: The System object or system ID string\n        year: The year of the report\n    \"\"\"\n    url = f\"{await self.get_api_base()}/emf/v2/{system.id}/report/{year}\"\n    async with self.aiohttp_session.get(\n        url, headers=self.get_authorized_headers()\n    ) as report_resp:\n        reports_json = await report_resp.json()\n        for report in dict_to_snake_case(reports_json):\n            yield SystemReport.from_api(**report)\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.quick_veto_zone_duration","title":"<code>quick_veto_zone_duration(zone, duration_hours, veto_type='heating')</code>  <code>async</code>","text":"<p>Updates the quick veto duration</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>duration_hours</code> <code>float</code> <p>Updates quick veto duration (in hours)</p> required <code>veto_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def quick_veto_zone_duration(\n    self,\n    zone: Zone,\n    duration_hours: float,\n    veto_type: str = \"heating\",\n):\n    \"\"\"\n    Updates the quick veto duration\n\n    Parameters:\n        zone: The target zone\n        duration_hours: Updates quick veto duration (in hours)\n        veto_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if zone.control_identifier.is_vrc700:\n        if veto_type not in ZONE_OPERATING_TYPES:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n    return await self.aiohttp_session.patch(\n        url,\n        json={\"duration\": duration_hours},\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.quick_veto_zone_temperature","title":"<code>quick_veto_zone_temperature(zone, temperature, duration_hours=None, default_duration=None, veto_type='heating')</code>  <code>async</code>","text":"<p>Temporarily overwrites the desired temperature in a zone</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>temperature</code> <code>float</code> <p>The target temperature</p> required <code>duration_hours</code> <code>float | None</code> <p>Optional, sets overwrite for this many hours</p> <code>None</code> <code>default_duration</code> <code>float | None</code> <p>Optional, falls back to this default duration if duration_hours is not given</p> <code>None</code> <code>veto_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def quick_veto_zone_temperature(\n    self,\n    zone: Zone,\n    temperature: float,\n    duration_hours: float | None = None,\n    default_duration: float | None = None,\n    veto_type: str = \"heating\",\n):\n    \"\"\"\n    Temporarily overwrites the desired temperature in a zone\n\n    Parameters:\n        zone: The target zone\n        temperature: The target temperature\n        duration_hours: Optional, sets overwrite for this many hours\n        default_duration: Optional, falls back to this default duration if duration_hours is not given\n        veto_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if not default_duration:\n        default_duration = DEFAULT_QUICK_VETO_DURATION\n    if zone.control_identifier.is_vrc700:\n        if veto_type not in ZONE_OPERATING_TYPES:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n    if zone.current_special_function == ZoneCurrentSpecialFunction.QUICK_VETO:\n        logger.debug(\n            f\"Patching quick veto for {zone.name} because it is already in quick veto mode\"\n        )\n        payload = {\n            \"desiredRoomTemperatureSetpoint\": temperature,\n        }\n        if duration_hours:\n            payload[\"duration\"] = duration_hours\n        return await self.aiohttp_session.patch(\n            url,\n            json=payload,\n            headers=self.get_authorized_headers(),\n        )\n    else:\n        return await self.aiohttp_session.post(\n            url,\n            json={\n                \"desiredRoomTemperatureSetpoint\": temperature,\n                \"duration\": duration_hours if duration_hours else default_duration,\n            },\n            headers=self.get_authorized_headers(),\n        )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_domestic_hot_water_circulation_time_program","title":"<code>set_domestic_hot_water_circulation_time_program(domestic_hot_water, time_program)</code>  <code>async</code>","text":"<p>Sets the schedule for the water circulation pump</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required <code>time_program</code> <code>DHWTimeProgram</code> <p>The schedule</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_domestic_hot_water_circulation_time_program(\n    self, domestic_hot_water: DomesticHotWater, time_program: DHWTimeProgram\n):\n    \"\"\"\n    Sets the schedule for the water circulation pump\n\n    Parameters:\n        domestic_hot_water: The water heater\n        time_program: The schedule\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/circulation-pump-time-windows\"\n    )\n    data = asdict(time_program)\n    del data[\"meta_info\"]\n    return await self.aiohttp_session.patch(\n        url,\n        json=dict_to_camel_case(data),\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_domestic_hot_water_operation_mode","title":"<code>set_domestic_hot_water_operation_mode(domestic_hot_water, mode)</code>  <code>async</code>","text":"<p>Sets the operation mode for water heating</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required <code>mode</code> <code>DHWOperationMode | DHWOperationModeVRC700</code> <p>The operation mode</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_domestic_hot_water_operation_mode(\n    self,\n    domestic_hot_water: DomesticHotWater,\n    mode: DHWOperationMode | DHWOperationModeVRC700,\n):\n    \"\"\"\n    Sets the operation mode for water heating\n\n    Parameters:\n        domestic_hot_water: The water heater\n        mode: The operation mode\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}/domestic-hot-water/\"\n        f\"{domestic_hot_water.index}/operation-mode\"\n    )\n    return await self.aiohttp_session.patch(\n        url,\n        json={\"operationMode\": str(mode)},\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_domestic_hot_water_temperature","title":"<code>set_domestic_hot_water_temperature(domestic_hot_water, temperature)</code>  <code>async</code>","text":"<p>Sets the desired hot water temperature</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required <code>temperature</code> <code>int | float</code> <p>The desired temperature, only whole numbers are supported by the API, floats get rounded</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_domestic_hot_water_temperature(\n    self, domestic_hot_water: DomesticHotWater, temperature: int | float\n):\n    \"\"\"\n    Sets the desired hot water temperature\n\n    Parameters:\n        domestic_hot_water: The water heater\n        temperature: The desired temperature, only whole numbers are supported by the API, floats get rounded\n    \"\"\"\n    if isinstance(temperature, float):\n        logger.warning(\"Domestic hot water can only be set to whole numbers\")\n        temperature = int(round(temperature, 0))\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/temperature\"\n    )\n    return await self.aiohttp_session.patch(\n        url, json={\"setpoint\": temperature}, headers=self.get_authorized_headers()\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_domestic_hot_water_time_program","title":"<code>set_domestic_hot_water_time_program(domestic_hot_water, time_program)</code>  <code>async</code>","text":"<p>Sets the schedule for heating water</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required <code>time_program</code> <code>DHWTimeProgram</code> <p>The schedule</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_domestic_hot_water_time_program(\n    self, domestic_hot_water: DomesticHotWater, time_program: DHWTimeProgram\n):\n    \"\"\"\n    Sets the schedule for heating water\n\n    Parameters:\n        domestic_hot_water: The water heater\n        time_program: The schedule\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/time-windows\"\n    )\n    data = asdict(time_program)\n    del data[\"meta_info\"]\n    return await self.aiohttp_session.patch(\n        url,\n        json=dict_to_camel_case(data),\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_holiday","title":"<code>set_holiday(system, start=None, end=None, setpoint=None)</code>  <code>async</code>","text":"<p>Sets away mode / holiday mode on a system</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The target system</p> required <code>start</code> <code>datetime | None</code> <p>Optional, datetime when the system goes into away mode. Defaults to now</p> <code>None</code> <code>end</code> <code>datetime | None</code> <p>Optional, datetime when away mode should end. Defaults to one year from now</p> <code>None</code> <code>setpoint</code> <code>float | None</code> <p>Optional, setpoint temperature during holiday, only supported on VRC700 controllers</p> <code>None</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_holiday(\n    self,\n    system: System,\n    start: datetime.datetime | None = None,\n    end: datetime.datetime | None = None,\n    setpoint: float | None = None,\n):\n    \"\"\"\n    Sets away mode / holiday mode on a system\n\n    Parameters:\n        system: The target system\n        start: Optional, datetime when the system goes into away mode. Defaults to now\n        end: Optional, datetime when away mode should end. Defaults to one year from now\n        setpoint: Optional, setpoint temperature during holiday, only supported on VRC700 controllers\n    \"\"\"\n    start, end = get_default_holiday_dates(start, end, system.timezone)\n    logger.debug(\n        \"Setting holiday mode for system %s to %s - %s\", system.id, start, end\n    )\n    if not start &lt;= end:\n        raise ValueError(\"Start of holiday mode must be before end\")\n\n    data = {\n        \"startDateTime\": datetime_format(start, with_microseconds=True),\n        \"endDateTime\": datetime_format(end, with_microseconds=True),\n    }\n\n    if system.control_identifier.is_vrc700:\n        url = f\"{await self.get_system_api_base(system.id)}/holiday\"\n        if setpoint is None:\n            raise ValueError(\"setpoint is required on this controller\")\n        data[\"setpoint\"] = setpoint  # type: ignore\n    else:\n        url = f\"{await self.get_system_api_base(system.id)}/away-mode\"\n        if setpoint is not None:\n            raise ValueError(\"setpoint is not supported on this controller\")\n\n    return await self.aiohttp_session.post(\n        url, json=data, headers=self.get_authorized_headers()\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_manual_mode_setpoint","title":"<code>set_manual_mode_setpoint(zone, temperature, setpoint_type='HEATING')</code>  <code>async</code>","text":"<p>Sets the desired temperature when in manual mode</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>temperature</code> <code>float</code> <p>The target temperature</p> required <code>setpoint_type</code> <code>str</code> <p>Either HEATING or COOLING</p> <code>'HEATING'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_manual_mode_setpoint(\n    self,\n    zone: Zone,\n    temperature: float,\n    setpoint_type: str = \"HEATING\",\n):\n    \"\"\"\n    Sets the desired temperature when in manual mode\n\n    Parameters:\n        zone: The target zone\n        temperature: The target temperature\n        setpoint_type: Either HEATING or COOLING\n    \"\"\"\n    logger.debug(\"Setting manual mode setpoint for %s\", zone.name)\n    url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/manual-mode-setpoint\"\n    payload = {\n        \"setpoint\": temperature,\n        \"type\": setpoint_type,\n    }\n    return await self.aiohttp_session.patch(\n        url,\n        json=payload,\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_set_back_temperature","title":"<code>set_set_back_temperature(zone, temperature, setback_type='heating')</code>  <code>async</code>","text":"<p>Sets the temperature that a zone gets lowered to in away mode</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>temperature</code> <code>float</code> <p>The setback temperature</p> required <code>setback_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_set_back_temperature(\n    self, zone: Zone, temperature: float, setback_type: str = \"heating\"\n):\n    \"\"\"\n    Sets the temperature that a zone gets lowered to in away mode\n\n    Parameters:\n        zone: The target zone\n        temperature: The setback temperature\n        setback_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if zone.control_identifier.is_vrc700:\n        if setback_type not in ZONE_OPERATING_TYPES:\n            raise ValueError(\n                f\"Invalid setback type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setback_type}/set-back-temperature\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/set-back-temperature\"\n    return await self.aiohttp_session.patch(\n        url,\n        json={\"setBackTemperature\": temperature},\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_ventilation_fan_stage","title":"<code>set_ventilation_fan_stage(ventilation, maximum_fan_stage, fan_stage_type)</code>  <code>async</code>","text":"<p>Sets the maximum fan stage for a stage type</p> <p>Parameters:</p> Name Type Description Default <code>ventilation</code> <code>Ventilation</code> <p>The ventilation device</p> required <code>maximum_fan_stage</code> <code>int</code> <p>The maximum fan speed, from 1-6</p> required <code>fan_stage_type</code> <code>VentilationFanStageType</code> <p>The fan stage type (day or night)</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_ventilation_fan_stage(\n    self,\n    ventilation: Ventilation,\n    maximum_fan_stage: int,\n    fan_stage_type: VentilationFanStageType,\n):\n    \"\"\"\n    Sets the maximum fan stage for a stage type\n\n    Parameters:\n        ventilation: The ventilation device\n        maximum_fan_stage: The maximum fan speed, from 1-6\n        fan_stage_type: The fan stage type (day or night)\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(ventilation.system_id)}\"\n        f\"/ventilation/{ventilation.index}/fan-stage\"\n    )\n    return await self.aiohttp_session.patch(\n        url,\n        json={\n            \"maximumFanStage\": maximum_fan_stage,\n            \"type\": str(fan_stage_type),\n        },\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_ventilation_operation_mode","title":"<code>set_ventilation_operation_mode(ventilation, mode)</code>  <code>async</code>","text":"<p>Sets the operation mode for a ventilation device</p> <p>Parameters:</p> Name Type Description Default <code>ventilation</code> <code>Ventilation</code> <p>The ventilation device</p> required <code>mode</code> <code>VentilationOperationMode</code> <p>The operation mode</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_ventilation_operation_mode(\n    self, ventilation: Ventilation, mode: VentilationOperationMode\n):\n    \"\"\"\n    Sets the operation mode for a ventilation device\n\n    Parameters:\n        ventilation: The ventilation device\n        mode: The operation mode\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(ventilation.system_id)}\"\n        f\"/ventilation/{ventilation.index}/operation-mode\"\n    )\n    return await self.aiohttp_session.patch(\n        url,\n        json={\n            \"operationMode\": str(mode),\n        },\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_zone_operating_mode","title":"<code>set_zone_operating_mode(zone, mode, operating_type='heating')</code>  <code>async</code>","text":"<p>Sets the operating mode for a zone</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>mode</code> <code>ZoneHeatingOperatingMode | ZoneHeatingOperatingModeVRC700</code> <p>The target operating mode</p> required <code>operating_type</code> <code>str</code> <p>Either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_zone_operating_mode(\n    self,\n    zone: Zone,\n    mode: ZoneHeatingOperatingMode | ZoneHeatingOperatingModeVRC700,\n    operating_type: str = \"heating\",\n):\n    \"\"\"\n    Sets the operating mode for a zone\n\n    Parameters:\n        zone: The target zone\n        mode: The target operating mode\n        operating_type: Either heating or cooling\n    \"\"\"\n    if operating_type not in ZONE_OPERATING_TYPES:\n        raise ValueError(\n            f\"Invalid HVAC mode, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n        )\n    if zone.control_identifier.is_vrc700:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/heating/operation-mode\"\n        key = \"operationMode\"\n        mode_enum = ZoneHeatingOperatingModeVRC700  # type: ignore\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/{operating_type}-operation-mode\"\n        key = f\"{operating_type}OperationMode\"\n        mode_enum = ZoneHeatingOperatingMode  # type: ignore\n\n    if mode not in mode_enum:\n        raise ValueError(\n            f\"Invalid mode, must be one of {', '.join(mode_enum.__members__)}\"\n        )\n\n    return await self.aiohttp_session.patch(\n        url,\n        json={key: str(mode)},\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-library/#myPyllant.api.MyPyllantAPI.set_zone_time_program","title":"<code>set_zone_time_program(zone, program_type, time_program, setback_type='heating')</code>  <code>async</code>","text":"<p>Sets the temperature that a zone gets lowered to in away mode</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>program_type</code> <code>str</code> <p>Which program to set</p> required <code>time_program</code> <code>ZoneTimeProgram</code> <p>The time schedule</p> required <code>setback_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_zone_time_program(\n    self,\n    zone: Zone,\n    program_type: str,\n    time_program: ZoneTimeProgram,\n    setback_type: str = \"heating\",\n):\n    \"\"\"\n    Sets the temperature that a zone gets lowered to in away mode\n\n    Parameters:\n        zone: The target zone\n        program_type: Which program to set\n        time_program: The time schedule\n        setback_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if program_type not in ZoneTimeProgramType:\n        raise ValueError(\n            \"Type must be either heating or cooling, not %s\", program_type\n        )\n    if zone.control_identifier.is_vrc700:\n        if setback_type not in ZONE_OPERATING_TYPES:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZONE_OPERATING_TYPES)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setback_type}/time-windows\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/time-windows\"\n    data = asdict(time_program)\n    data[\"type\"] = program_type\n    del data[\"meta_info\"]\n    return await self.aiohttp_session.patch(\n        url,\n        json=dict_to_camel_case(data),\n        headers=self.get_authorized_headers(),\n    )\n</code></pre>"},{"location":"2-services/","title":"Services","text":"<p>There are custom services for almost every functionality of the myVAILLANT app:</p> Name Description Target Fields Set quick veto Sets quick veto temperature with optional duration climate Temperature, Duration Set manual mode setpoint Sets temperature for manual mode climate Temperature, Type Cancel quick veto Cancels quick veto temperature and returns to normal schedule / manual setpoint climate Set holiday Set holiday / away mode with start / end or duration climate Start Date, End Date, Duration Cancel Holiday Cancel holiday / away mode climate Set Zone Time Program Updates the time program for a zone climate Type, Time Program Set Water Heater Time Program Updates the time program for a water heater water_heater Time Program Set Water Heater Circulation Time Program Updates the time program for the circulation pump of a water heater water_heater Time Program Export Data Exports data from the mypyllant library Data, Data Resolution, Start Date, End Date Generate Test Data Generates test data for the mypyllant library and returns it as YAML Export Yearly Energy Reports Exports energy reports in CSV format per year Year <p>Additionally, there are home assistant's built in services for climate controls, water heaters, and switches.</p> <p>Search for \"myvaillant\" in Developer Tools &gt; Services in your Home Assistant instance to get the full list plus an interactive UI.</p> <p></p> <p></p>"},{"location":"2-services/#exporting-data","title":"Exporting Data","text":"<ul> <li>mypyllant.report for   exporting yearly energy reports (in CSV format)</li> <li>mypyllant.export for   exporting raw data of your system</li> <li>mypyllant.generate_test_data   for generating test data to contribute to the myPyllant library</li> </ul>"},{"location":"2-services/#setting-a-time-program","title":"Setting a Time Program","text":"<p>The following services can be used to set time programs:</p> <ul> <li>mypyllant.set_zone_time_program   for climate zone temperature schedule (requires an additional <code>program_type</code>)</li> <li>mypyllant.set_dhw_time_program   for water heater temperature schedule</li> <li>mypyllant.set_dhw_circulation_time_program   for circulation pump schedule on water heaters</li> </ul> <p>You can look up your current time programs in the developer states view under attributes for your zones and water heater.</p> <p>Times in the time program are given in minutes since midnight in UTC.</p> <p>Disabling a time window</p> <p>You can delete all time windows on a day by sending an empty list, for example <code>monday: []</code>.</p> ClimateWater HeaterCirculation Pump <pre><code>service: mypyllant.set_zone_time_program\ndata:\n  program_type: heating\n  time_program:\n    monday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    tuesday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    wednesday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    thursday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    friday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    saturday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    sunday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    type: heating\ntarget:\n  entity_id: climate.home_zone_1_circuit_0_climate\n</code></pre> <pre><code>service: mypyllant.set_dhw_time_program\ndata:\n  time_program:\n    monday:\n      - start_time: 420\n        end_time: 1290\n    tuesday:\n      - start_time: 420\n        end_time: 1290\n    wednesday:\n      - start_time: 420\n        end_time: 1290\n    thursday:\n      - start_time: 420\n        end_time: 1290\n    friday:\n      - start_time: 420\n        end_time: 1290\n    saturday:\n      - start_time: 420\n        end_time: 1290\n    sunday:\n      - start_time: 420\n        end_time: 1290\n    type: heating\ntarget:\n  entity_id: water_heater.home_domestic_hot_water_0\n</code></pre> <pre><code>service: mypyllant.set_dhw_circulation_time_program\ndata:\n  time_program:\n    monday:\n      - start_time: 420\n        end_time: 1290\n    tuesday:\n      - start_time: 420\n        end_time: 1290\n    wednesday:\n      - start_time: 420\n        end_time: 1290\n    thursday:\n      - start_time: 420\n        end_time: 1290\n    friday:\n      - start_time: 420\n        end_time: 1290\n    saturday:\n      - start_time: 420\n        end_time: 1290\n    sunday:\n      - start_time: 420\n        end_time: 1290\n    type: heating\ntarget:\n  entity_id: water_heater.home_domestic_hot_water_0\n</code></pre>"},{"location":"3-contributing/","title":"Contributing","text":""},{"location":"3-contributing/#cloning-installing","title":"Cloning &amp; Installing","text":"<p>Warning</p> <p>You need at least Python 3.10.</p> <p>Fork and clone the mypyllant-component repository, then from within the directory run:</p> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install -r dev-requirements.txt\npre-commit install\n# Make your changes\ngit commit -m ...  # Code formatting, analysis, and tests are run automatically before the commit\n</code></pre> <p>If you also need to modify the underlying myPyllant library, clone &amp; install it in editable mode in <code>mypyllant-component</code>:</p> <pre><code># From within the mypyllant-component directory\ngit clone https://github.com/signalkraft/myPyllant.git ../myPyllant\npip install -e ../myPyllant\n</code></pre> <p>Now you can modify <code>myPyllant/src</code> and directly develop against these changes in <code>mypyllant-component</code>.</p>"},{"location":"3-contributing/#vscode-dev-container","title":"VSCode Dev Container","text":"<p>There's also a VSCode dev container available in <code>.devcontainer.json</code>, provided by github.com/ml1nk.</p>"},{"location":"3-contributing/#debugging","title":"Debugging","text":"<p>When debugging or reporting issues, turn on debug logging by adding this to your <code>configuration.yaml</code> and restarting Home Assistant:</p> <pre><code>logger:\n  default: warning\n  logs:\n    custom_components.mypyllant: debug\n    myPyllant: debug\n</code></pre> <p>Then you can check for errors in System &gt; Logs and attach the logs when creating an issue.</p>"},{"location":"3-contributing/#testing-in-docker","title":"Testing in Docker","text":"<p>To test your changes, you can spin up a quick Docker environment:</p> <ol> <li>Follow the cloning &amp; installation steps above</li> <li>Copy <code>.env.sample</code> to <code>.env</code> and add your credentials in the new file</li> <li>Run <code>docker compose up</code></li> </ol> <p>After HA started, open http://localhost:8123 in your browser and sign in with user <code>test</code> and password <code>test</code>.</p> <p>The integration should be configured and show entities on the default dashboard.</p> <p></p>"},{"location":"3-contributing/#contributing-to-the-underlying-mypyllant-library","title":"Contributing to the underlying myPyllant library","text":"<p>Warning</p> <p>You need at least Python 3.10</p> <p>Fork and clone the myPyllant repository, then from within the directory run:</p> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install -r dev-requirements.txt\npip install -e .\npre-commit install\n# Make your changes\ngit commit -m ...  # Code formatting, analysis, and tests are run automatically before the commit\n</code></pre>"},{"location":"3-contributing/#supporting-new-countries","title":"Supporting new Countries","text":"<p>The myVAILLANT app uses Keycloak and OIDC for authentication, with a realm for each country and brand. There is a script to check which countries are supported:</p> <pre><code>python3 -m myPyllant.tests.find_countries\n</code></pre> <p>Copy the resulting dictionary into https://github.com/signalkraft/myPyllant/blob/main/src/myPyllant/const.py</p> Source code in <code>myPyllant/tests/find_countries.py</code> <pre><code>def main():\n    print(\"COUNTRIES = {\")\n    for brand in BRANDS.keys():\n        if brand == \"bulex\":\n            # Bulex has no country-specific realms\n            continue\n        print(f'    \"{brand}\": {{')\n        for country_name, country in countries_with_realm(brand):\n            print(f'        \"{country_name}\": \"{country}\",')\n        print(\"    },\")\n    print(\"}\")\n</code></pre> <p>options: show_source: true heading_level: 0</p>"},{"location":"3-contributing/#contributing-test-data","title":"Contributing Test Data","text":"<p>Because the myVAILLANT API isn't documented, you can help the development of this library by contributing test data:</p> Home Assistant ServiceShellDocker <p></p> <p>Select <code>mypyllant.generate_test_data</code> and call the service.</p> <pre><code>python3 -m myPyllant.tests.generate_test_data -h\npython3 -m myPyllant.tests.generate_test_data username password brand --country country\n</code></pre> <pre><code>docker run -v $(pwd)/test_data:/build/src/myPyllant/tests/json -ti ghcr.io/signalkraft/mypyllant:latest python3 -m myPyllant.tests.generate_test_data username password brand --country country\n</code></pre> <p>With docker, the results will be put into <code>test_data/</code>.</p> <p>You can then either create a PR with the created folder, or zip it and attach it to an issue.</p> <p>Generate json data for running testcases.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>myVAILLANT app username</p> required <code>password</code> <code>str</code> <p>myVAILLANT app password</p> required <code>brand</code> <code>str</code> <p>Brand, such as vaillant or bulex</p> required <code>country</code> <code>str</code> <p>myVAILLANT app country</p> <code>None</code> <code>write_results</code> <code>bool</code> <p>Whether to write results to disk, or return them</p> <code>True</code> Source code in <code>myPyllant/tests/generate_test_data.py</code> <pre><code>async def main(user, password, brand, country=None, write_results=True):\n    \"\"\"\n    Generate json data for running testcases.\n\n    Parameters:\n        user (str): myVAILLANT app username\n        password (str): myVAILLANT app password\n        brand (str): Brand, such as vaillant or bulex\n        country (str): myVAILLANT app country\n        write_results (bool): Whether to write results to disk, or return them\n    \"\"\"\n    from myPyllant.api import MyPyllantAPI\n    from myPyllant.enums import DeviceDataBucketResolution\n    from myPyllant.utils import datetime_format\n\n    results: dict[str, Any] = {}\n    json_dir = user_json_dir(user)\n    if write_results:\n        json_dir.mkdir(parents=True, exist_ok=True)\n\n    def create_result(result, name, directory=None):\n        if write_results:\n            if directory:\n                write_dir = json_dir / directory\n            else:\n                write_dir = json_dir\n            with open(write_dir / f\"{name}.json\", \"w\") as fh_json:\n                fh_json.write(json.dumps(result, indent=2))\n        if directory:\n            if directory not in results:\n                results[directory] = {}\n            results[directory][name] = result\n        else:\n            results[name] = result\n\n    async with MyPyllantAPI(user, password, brand, country) as api:\n        homes_url = f\"{get_api_base()}/homes\"\n        async with api.aiohttp_session.get(\n            homes_url, headers=api.get_authorized_headers()\n        ) as homes_resp:\n            homes = await homes_resp.json()\n            anonymized_homes = _recursive_data_anonymize(copy.deepcopy(homes), SALT)\n            for home in anonymized_homes:\n                if \"address\" in home:\n                    home.pop(\"address\")\n            create_result(\n                anonymized_homes,\n                name=\"homes\",\n            )\n\n        if not homes:\n            # No homes means no systems to generate test data for\n            print(\"No homes found.\")\n            if write_results:\n                print(f\"Wrote homes.json to {json_dir}\")\n                exit(0)\n            else:\n                return results\n\n        for home in homes:\n            anonymized_home = _recursive_data_anonymize(copy.deepcopy(home), SALT)\n            anonymized_system_id = anonymized_home[\"systemId\"]\n            real_system_id = home[\"systemId\"]\n            print(f\"Generating test data for {anonymized_system_id}...\")\n\n            if write_results:\n                (json_dir / anonymized_system_id).mkdir(parents=True, exist_ok=True)\n\n            control_identifier_url = f\"{get_api_base()}/systems/{real_system_id}/meta-info/control-identifier\"\n            try:\n                async with api.aiohttp_session.get(\n                    control_identifier_url, headers=api.get_authorized_headers()\n                ) as ci_response:\n                    control_identifier_json = await ci_response.json()\n                    control_identifier = control_identifier_json[\"controlIdentifier\"]\n                    create_result(\n                        control_identifier_json,\n                        \"control_identifier\",\n                        anonymized_system_id,\n                    )\n            except Exception as e:\n                logger.error(\n                    f\"Error fetching {control_identifier_url}: {e}\", exc_info=e\n                )\n                control_identifier = DEFAULT_CONTROL_IDENTIFIER\n\n            tz_url = f\"{get_api_base()}/systems/{real_system_id}/meta-info/time-zone\"\n            try:\n                async with api.aiohttp_session.get(\n                    tz_url, headers=api.get_authorized_headers()\n                ) as tz_response:\n                    create_result(\n                        await tz_response.json(),\n                        \"time_zone\",\n                        anonymized_system_id,\n                    )\n            except Exception as e:\n                logger.error(f\"Error fetching {tz_url}: {e}\", exc_info=e)\n\n            dtc_url = (\n                f\"{get_api_base()}/systems/{real_system_id}/diagnostic-trouble-codes\"\n            )\n            try:\n                async with api.aiohttp_session.get(\n                    dtc_url, headers=api.get_authorized_headers()\n                ) as dtc_response:\n                    dtc = await dtc_response.json()\n                    anonymized_dtc = _recursive_data_anonymize(copy.deepcopy(dtc), SALT)\n                    create_result(\n                        anonymized_dtc,\n                        \"diagnostic_trouble_codes\",\n                        anonymized_system_id,\n                    )\n            except Exception as e:\n                logger.error(f\"Error fetching {dtc_url}: {e}\", exc_info=e)\n\n            try:\n                connection_status_url = f\"{get_api_base()}/systems/{real_system_id}/meta-info/connection-status\"\n                async with api.aiohttp_session.get(\n                    connection_status_url, headers=api.get_authorized_headers()\n                ) as status_resp:\n                    create_result(\n                        await status_resp.json(),\n                        \"connection_status\",\n                        anonymized_system_id,\n                    )\n            except Exception as e:\n                logger.error(f\"Error fetching {connection_status_url}: {e}\", exc_info=e)\n\n            system_url = get_system_api_base(real_system_id, control_identifier)\n            try:\n                async with api.aiohttp_session.get(\n                    system_url, headers=api.get_authorized_headers()\n                ) as system_resp:\n                    system = await system_resp.json()\n                    anonymized_homes = _recursive_data_anonymize(\n                        copy.deepcopy(system), SALT\n                    )\n                    create_result(\n                        anonymized_homes,\n                        \"system\",\n                        anonymized_system_id,\n                    )\n            except Exception as e:\n                logger.error(f\"Error fetching {system_url}: {e}\", exc_info=e)\n\n            current_system_url = (\n                f\"{get_api_base()}/emf/v2/{real_system_id}/currentSystem\"\n            )\n            try:\n                async with api.aiohttp_session.get(\n                    current_system_url, headers=api.get_authorized_headers()\n                ) as current_system_resp:\n                    current_system = await current_system_resp.json()\n                    anonymized_current_system = _recursive_data_anonymize(\n                        copy.deepcopy(current_system), SALT\n                    )\n                    create_result(\n                        anonymized_current_system,\n                        \"current_system\",\n                        anonymized_system_id,\n                    )\n            except Exception as e:\n                logger.error(f\"Error fetching {current_system_url}: {e}\", exc_info=e)\n\n            mpc_url = f\"{get_api_base()}/hem/{real_system_id}/mpc\"\n            try:\n                async with api.aiohttp_session.get(\n                    mpc_url, headers=api.get_authorized_headers()\n                ) as mpc_resp:\n                    mpc = await mpc_resp.json()\n                    anonymized_mpc = _recursive_data_anonymize(copy.deepcopy(mpc), SALT)\n                    create_result(\n                        anonymized_mpc,\n                        \"mpc\",\n                        anonymized_system_id,\n                    )\n            except Exception as e:\n                logger.error(f\"Error fetching {mpc_url}: {e}\", exc_info=e)\n\n            rts_url = f\"{get_api_base()}/rts/{real_system_id}/devices\"\n            try:\n                async with api.aiohttp_session.get(\n                    rts_url, headers=api.get_authorized_headers()\n                ) as rts_resp:\n                    rts = await rts_resp.json()\n                    anonymized_rts = _recursive_data_anonymize(copy.deepcopy(rts), SALT)\n                    create_result(\n                        anonymized_rts,\n                        \"rts\",\n                        anonymized_system_id,\n                    )\n            except Exception as e:\n                logger.error(f\"Error fetching {rts_url}: {e}\", exc_info=e)\n\n            device = current_system[\"primary_heat_generator\"]\n            start = datetime.now().replace(\n                microsecond=0, second=0, minute=0, hour=0\n            ) - timedelta(days=1)\n            end = datetime.now().replace(microsecond=0, second=0, minute=0, hour=0)\n            if device and \"data\" in device:\n                querystring = {\n                    \"resolution\": DeviceDataBucketResolution.HOUR,\n                    \"operationMode\": device[\"data\"][0][\"operation_mode\"],\n                    \"energyType\": device[\"data\"][0][\"value_type\"],\n                    \"startDate\": datetime_format(start),\n                    \"endDate\": datetime_format(end),\n                }\n                device_buckets_url = (\n                    f\"{get_api_base()}/emf/v2/{real_system_id}/\"\n                    f\"devices/{device['device_uuid']}/buckets?{urlencode(querystring)}\"\n                )\n                try:\n                    async with api.aiohttp_session.get(\n                        device_buckets_url, headers=api.get_authorized_headers()\n                    ) as device_buckets_resp:\n                        device_buckets = await device_buckets_resp.json()\n                    create_result(\n                        device_buckets,\n                        \"device_buckets\",\n                        anonymized_system_id,\n                    )\n                except Exception as e:\n                    logger.error(\n                        f\"Error fetching {device_buckets_url}: {e}\", exc_info=e\n                    )\n\n    if write_results:\n        print(f\"Wrote test data to {json_dir}\")\n        print()\n        print(\n            \"Results are already anonymized, but the myVAILLANT API may change and contain new, sensitive data.\"\n        )\n        print(\"You should check the contents of the JSON files before sharing them.\")\n    else:\n        return results\n</code></pre> <p>options: show_source: true heading_level: 0</p>"},{"location":"3-contributing/#adding-new-api-endpoints","title":"Adding new API endpoints","text":"<p>If your myVAILLANT app has more features than this integration, chances are you have a more complex system then me. You can reverse engineer the API endpoints and open an issue with the requests + responses. See Reverse Engineering for a tutorial.</p>"},{"location":"3-contributing/#running-commands-on-your-home-assistant-installation-in-docker","title":"Running commands on your Home Assistant installation in Docker","text":"<p>If you're using this component in a Home Assistant installation that uses docker compose, you can run these commands directly (from the folder that contains your <code>docker-compose.yml</code>):</p> <pre><code>docker compose exec homeassistant python3 -m myPyllant.tests.generate_test_data username password brand --country country\n# Note the output folder\ndocker compose cp homeassistant:&lt;testdata folder&gt; .\n# Test data will be copied to your current directory\n</code></pre>"},{"location":"3-reverse-engineering/","title":"Reverse Engineering Android Apps","text":"<p>Any Android app that makes HTTPS API requests (in this case to the myVAILLANT API), can be reverse engineered with an Android device and a laptop / PC that runs ADB. Both need to be on the same network. Creating a hotspot from the Android device also works.</p> <ol> <li>Run mitmproxy on your laptop, for example in Docker:     <pre><code>docker run --rm -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -p 0.0.0.0:8080:8080 -p 127.0.0.1:8081:8081 mitmproxy/mitmproxy mitmweb --web-host 0.0.0.0\n</code></pre></li> <li>In your Android WI-FI settings (see screenshot below) set a manual proxy to the IP of the device running mitmproxy on port 8080.    Add a bypass for <code>identity.vaillant-group.com</code><sup>1</sup></li> <li>Visit mitm.it on your Android device, download the CA cert &amp; install it through the settings app</li> <li>Install ADB on your laptop and connect your Android device to USB in debug mode</li> <li>Look for the myVAILLANT APK online and download it</li> <li> <p>Run apk-mitm on the APK and install it with adb</p> <pre><code>apk-mitm myVAILLANT.xapk\nunzip ./myVAILLANT-patched.xapk\nadb install-multiple com.vaillantgroup.enduserapp.vaillant.apk config.mdpi.apk config.fr.apk config.en.apk config.arm64_v8a.apk\n</code></pre> </li> <li> <p>You should see all API calls in mitmproxy's web interface on http://127.0.0.1:8081 now. </p> </li> </ol> <p>Note</p> <p>If you can't log in with SSO because of a certificate error, make sure you added the exception to the proxy settings.</p> <p>If you can log in, but the app reports an error, the unpinning didn't work. You can try MagiskTrustUserCertson if you have a rooted Android device.</p> <p> </p> Source: digitalcitizen.life <ol> <li> <p>The single-sign on gets handled in your browser, which uses certificate pinning as an added security measure\u00a0\u21a9</p> </li> </ol>"}]}